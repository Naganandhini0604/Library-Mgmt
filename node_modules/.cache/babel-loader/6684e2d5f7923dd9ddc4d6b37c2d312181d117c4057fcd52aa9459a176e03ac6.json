{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n */\n\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    return {\n      $setOnInsert: filter\n    };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (!Array.isArray(val) || val.find(v => typeof v !== 'string')) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + 'an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Object} options\n * @param {Boolean|String} [options.strict]\n * @param {Boolean} [options.omitUndefined]\n * @param {Query} context\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  let useNestedStrict;\n  if (options.useNestedStrict === undefined) {\n    useNestedStrict = schema.options.useNestedStrict;\n  } else {\n    useNestedStrict = options.useNestedStrict;\n  }\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _handleCastError(error, context, key, aggregatedError);\n          }\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            // Special case to make sure `strict` bubbles down correctly to\n            // single nested re: gh-8735\n            let _strict = strict;\n            if (useNestedStrict !== false && schematype.schema.options.hasOwnProperty('strict')) {\n              _strict = schematype.schema.options.strict;\n            } else if (useNestedStrict === false) {\n              _strict = schema.options.strict;\n            }\n            try {\n              obj[key] = schematype.castForQuery(val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _handleCastError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _handleCastError(error, context, key, aggregatedError);\n            }\n          }\n          if (options.omitUndefined && obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (useNestedStrict && v && v.schema && 'strict' in v.schema.options) {\n          _strict = v.schema.options.strict;\n        }\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;\n      }\n    } else {\n      const checkPath = key === '$each' || key === '$or' || key === '$and' || key === '$in' ? pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n      let isStrict = strict;\n      if (useNestedStrict && pathDetails && pathDetails.schema && 'strict' in pathDetails.schema.options) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      }\n    }\n  }\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _handleCastError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/*!\n * These ops require no casting because the RHS doesn't do anything.\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n  const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n    return Boolean(val);\n  }\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\n      $applySetters: schema[schemaMixedSymbol] != null\n    });\n  }\n  return schema.castForQueryWrapper({\n    val: val,\n    context: context\n  });\n}","map":{"version":3,"names":["CastError","require","MongooseError","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","upsert","ret","val","hasDollarKey","overwrite","$set","splice","indexOf","push","startsWith","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","$setOnInsert","find","v","pref","strict","prefix","hasKeys","schematype","key","aggregatedError","useNestedStrict","_getSchema","_res","caster","castOps","$each","castUpdateVal","error","_handleCastError","$slice","$sort","$position","$isSingleNested","_strict","hasOwnProperty","castForQuery","omitUndefined","pathToCheck","_getPathType","pathType","isObject","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","err","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","castForQueryWrapper","$type","Boolean","$skipQueryCastForUpdate","$fullPath","match","$applySetters"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n */\n\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n\n  filter = filter || {};\n\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        (!overwrite || hasDollarKey)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    return { $setOnInsert: filter };\n  }\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (!Array.isArray(val) || val.find(v => typeof v !== 'string')) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        'an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Object} options\n * @param {Boolean|String} [options.strict]\n * @param {Boolean} [options.omitUndefined]\n * @param {Query} context\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  let useNestedStrict;\n  if (options.useNestedStrict === undefined) {\n    useNestedStrict = schema.options.useNestedStrict;\n  } else {\n    useNestedStrict = options.useNestedStrict;\n  }\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _handleCastError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            // Special case to make sure `strict` bubbles down correctly to\n            // single nested re: gh-8735\n            let _strict = strict;\n            if (useNestedStrict !== false && schematype.schema.options.hasOwnProperty('strict')) {\n              _strict = schematype.schema.options.strict;\n            } else if (useNestedStrict === false) {\n              _strict = schema.options.strict;\n            }\n            try {\n              obj[key] = schematype.castForQuery(val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _handleCastError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _handleCastError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (options.omitUndefined && obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (useNestedStrict &&\n            v &&\n            v.schema &&\n            'strict' in v.schema.options) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (useNestedStrict &&\n          pathDetails &&\n          pathDetails.schema &&\n          'strict' in pathDetails.schema.options) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _handleCastError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/*!\n * These ops require no casting because the RHS doesn't do anything.\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\n      $applySetters: schema[schemaMixedSymbol] != null\n    });\n  }\n\n  return schema.castForQueryWrapper({ val: val, context: context });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}