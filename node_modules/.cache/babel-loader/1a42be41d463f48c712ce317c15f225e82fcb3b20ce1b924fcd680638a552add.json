{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies\n */\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n  if (typeof options === 'undefined') {\n    options = {};\n    options.defaults = true;\n  }\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true,\n    defaults: options.defaults\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n    if (typeof type.selected !== 'boolean') return;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    const mongooseResult = Object.assign({}, res.result);\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n    return callback(null, mongooseResult);\n  };\n};","map":{"version":3,"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","opts","_localModel","model","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","defaults","skipId","isNew","willInit","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","addedPath","analyzePath","$isMongooseArray","$isMongooseDocumentArray","caster","_addedPaths","plusPath","hasPlusPath","pieces","split","cur","i","val","option","Array","isArray","virtuals","assign","map","slice","handleDeleteWriteOpResult","callback","_handleDeleteWriteOpResult","error","res","mongooseResult","result","deletedCount","n"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/queryhelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n  if (typeof options === 'undefined') {\n    options = {};\n    options.defaults = true;\n  }\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true,\n    defaults: options.defaults\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    const mongooseResult = Object.assign({}, res.result);\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n    return callback(null, mongooseResult);\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}