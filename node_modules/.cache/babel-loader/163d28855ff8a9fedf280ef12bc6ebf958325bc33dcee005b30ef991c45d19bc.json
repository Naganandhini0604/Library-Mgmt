{"ast":null,"code":"'use strict';\n\nconst cloneRegExp = require('regexp-clone');\nconst Decimal = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst specialProperties = require('./specialProperties');\nconst isMongooseObject = require('./isMongooseObject');\nconst getFunctionName = require('./getFunctionName');\nconst isBsonType = require('./isBsonType');\nconst isObject = require('./isObject');\nconst symbols = require('./symbols');\nconst utils = require('../utils');\n\n/*!\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n  if (isMongooseObject(obj)) {\n    // Single nested subdocs should apply getters later in `applyGetters()`\n    // when calling `toObject()`. See gh-7442, gh-8295\n    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {\n      options = Object.assign({}, options, {\n        getters: false\n      });\n    }\n    if (utils.isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      return obj.toJSON(options);\n    }\n    return obj.toObject(options);\n  }\n  if (obj.constructor) {\n    switch (getFunctionName(obj.constructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new obj.constructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n  if (obj instanceof ObjectId) {\n    return new ObjectId(obj.id);\n  }\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n  if (!obj.constructor && isObject(obj)) {\n    // object created with Object.create(null)\n    return cloneObject(obj, options, isArrayChild);\n  }\n  if (obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n  if (obj.valueOf != null) {\n    return obj.valueOf();\n  }\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const ret = {};\n  let hasKeys;\n  for (const k of Object.keys(obj)) {\n    if (specialProperties.has(k)) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[k], options);\n    if (!minimize || typeof val !== 'undefined') {\n      if (minimize === false && typeof val === 'undefined') {\n        delete ret[k];\n      } else {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  }\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\nfunction cloneArray(arr, options) {\n  const ret = [];\n  for (const item of arr) {\n    ret.push(clone(item, options, true));\n  }\n  return ret;\n}","map":{"version":3,"names":["cloneRegExp","require","Decimal","ObjectId","specialProperties","isMongooseObject","getFunctionName","isBsonType","isObject","symbols","utils","clone","obj","options","isArrayChild","Array","isArray","cloneArray","_skipSingleNestedGetters","$isSingleNested","Object","assign","getters","isPOJO","$__","_doc","json","toJSON","toObject","constructor","cloneObject","id","flattenDecimals","fromString","toString","schemaTypeSymbol","bson","toBSON","valueOf","module","exports","minimize","ret","hasKeys","k","keys","has","val","arr","item","push"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/clone.js"],"sourcesContent":["'use strict';\n\n\nconst cloneRegExp = require('regexp-clone');\nconst Decimal = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst specialProperties = require('./specialProperties');\nconst isMongooseObject = require('./isMongooseObject');\nconst getFunctionName = require('./getFunctionName');\nconst isBsonType = require('./isBsonType');\nconst isObject = require('./isObject');\nconst symbols = require('./symbols');\nconst utils = require('../utils');\n\n\n/*!\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    // Single nested subdocs should apply getters later in `applyGetters()`\n    // when calling `toObject()`. See gh-7442, gh-8295\n    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {\n      options = Object.assign({}, options, { getters: false });\n    }\n\n    if (utils.isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      return obj.toJSON(options);\n    }\n    return obj.toObject(options);\n  }\n\n  if (obj.constructor) {\n    switch (getFunctionName(obj.constructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new obj.constructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (obj instanceof ObjectId) {\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  if (!obj.constructor && isObject(obj)) {\n    // object created with Object.create(null)\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (obj.valueOf != null) {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const ret = {};\n  let hasKeys;\n\n  for (const k of Object.keys(obj)) {\n    if (specialProperties.has(k)) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[k], options);\n\n    if (!minimize || (typeof val !== 'undefined')) {\n      if (minimize === false && typeof val === 'undefined') {\n        delete ret[k];\n      } else {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  const ret = [];\n\n  for (const item of arr) {\n    ret.push(clone(item, options, true));\n  }\n\n  return ret;\n}"],"mappings":"AAAA,YAAY;;AAGZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,OAAO,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAME,QAAQ,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAC7C,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAMI,gBAAgB,GAAGJ,OAAO,CAAC,oBAAoB,CAAC;AACtD,MAAMK,eAAe,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AACpD,MAAMM,UAAU,GAAGN,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAMO,QAAQ,GAAGP,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMQ,OAAO,GAAGR,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMS,KAAK,GAAGT,OAAO,CAAC,UAAU,CAAC;;AAGjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASU,KAAK,CAACC,GAAG,EAAEC,OAAO,EAAEC,YAAY,EAAE;EACzC,IAAIF,GAAG,IAAI,IAAI,EAAE;IACf,OAAOA,GAAG;EACZ;EAEA,IAAIG,KAAK,CAACC,OAAO,CAACJ,GAAG,CAAC,EAAE;IACtB,OAAOK,UAAU,CAACL,GAAG,EAAEC,OAAO,CAAC;EACjC;EAEA,IAAIR,gBAAgB,CAACO,GAAG,CAAC,EAAE;IACzB;IACA;IACA,IAAIC,OAAO,IAAIA,OAAO,CAACK,wBAAwB,IAAIN,GAAG,CAACO,eAAe,EAAE;MACtEN,OAAO,GAAGO,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAER,OAAO,EAAE;QAAES,OAAO,EAAE;MAAM,CAAC,CAAC;IAC1D;IAEA,IAAIZ,KAAK,CAACa,MAAM,CAACX,GAAG,CAAC,IAAIA,GAAG,CAACY,GAAG,IAAI,IAAI,IAAIZ,GAAG,CAACa,IAAI,IAAI,IAAI,EAAE;MAC5D,OAAOb,GAAG,CAACa,IAAI;IACjB;IAEA,IAAIZ,OAAO,IAAIA,OAAO,CAACa,IAAI,IAAI,OAAOd,GAAG,CAACe,MAAM,KAAK,UAAU,EAAE;MAC/D,OAAOf,GAAG,CAACe,MAAM,CAACd,OAAO,CAAC;IAC5B;IACA,OAAOD,GAAG,CAACgB,QAAQ,CAACf,OAAO,CAAC;EAC9B;EAEA,IAAID,GAAG,CAACiB,WAAW,EAAE;IACnB,QAAQvB,eAAe,CAACM,GAAG,CAACiB,WAAW,CAAC;MACtC,KAAK,QAAQ;QACX,OAAOC,WAAW,CAAClB,GAAG,EAAEC,OAAO,EAAEC,YAAY,CAAC;MAChD,KAAK,MAAM;QACT,OAAO,IAAIF,GAAG,CAACiB,WAAW,CAAC,CAACjB,GAAG,CAAC;MAClC,KAAK,QAAQ;QACX,OAAOZ,WAAW,CAACY,GAAG,CAAC;MACzB;QACE;QACA;IAAM;EAEZ;EAEA,IAAIA,GAAG,YAAYT,QAAQ,EAAE;IAC3B,OAAO,IAAIA,QAAQ,CAACS,GAAG,CAACmB,EAAE,CAAC;EAC7B;EAEA,IAAIxB,UAAU,CAACK,GAAG,EAAE,YAAY,CAAC,EAAE;IACjC,IAAIC,OAAO,IAAIA,OAAO,CAACmB,eAAe,EAAE;MACtC,OAAOpB,GAAG,CAACe,MAAM,EAAE;IACrB;IACA,OAAOzB,OAAO,CAAC+B,UAAU,CAACrB,GAAG,CAACsB,QAAQ,EAAE,CAAC;EAC3C;EAEA,IAAI,CAACtB,GAAG,CAACiB,WAAW,IAAIrB,QAAQ,CAACI,GAAG,CAAC,EAAE;IACrC;IACA,OAAOkB,WAAW,CAAClB,GAAG,EAAEC,OAAO,EAAEC,YAAY,CAAC;EAChD;EAEA,IAAIF,GAAG,CAACH,OAAO,CAAC0B,gBAAgB,CAAC,EAAE;IACjC,OAAOvB,GAAG,CAACD,KAAK,EAAE;EACpB;;EAEA;EACA;EACA;EACA,IAAIE,OAAO,IAAIA,OAAO,CAACuB,IAAI,IAAI,OAAOxB,GAAG,CAACyB,MAAM,KAAK,UAAU,EAAE;IAC/D,OAAOzB,GAAG;EACZ;EAEA,IAAIA,GAAG,CAAC0B,OAAO,IAAI,IAAI,EAAE;IACvB,OAAO1B,GAAG,CAAC0B,OAAO,EAAE;EACtB;EAEA,OAAOR,WAAW,CAAClB,GAAG,EAAEC,OAAO,EAAEC,YAAY,CAAC;AAChD;AACAyB,MAAM,CAACC,OAAO,GAAG7B,KAAK;;AAEtB;AACA;AACA;;AAEA,SAASmB,WAAW,CAAClB,GAAG,EAAEC,OAAO,EAAEC,YAAY,EAAE;EAC/C,MAAM2B,QAAQ,GAAG5B,OAAO,IAAIA,OAAO,CAAC4B,QAAQ;EAC5C,MAAMC,GAAG,GAAG,CAAC,CAAC;EACd,IAAIC,OAAO;EAEX,KAAK,MAAMC,CAAC,IAAIxB,MAAM,CAACyB,IAAI,CAACjC,GAAG,CAAC,EAAE;IAChC,IAAIR,iBAAiB,CAAC0C,GAAG,CAACF,CAAC,CAAC,EAAE;MAC5B;IACF;;IAEA;IACA,MAAMG,GAAG,GAAGpC,KAAK,CAACC,GAAG,CAACgC,CAAC,CAAC,EAAE/B,OAAO,CAAC;IAElC,IAAI,CAAC4B,QAAQ,IAAK,OAAOM,GAAG,KAAK,WAAY,EAAE;MAC7C,IAAIN,QAAQ,KAAK,KAAK,IAAI,OAAOM,GAAG,KAAK,WAAW,EAAE;QACpD,OAAOL,GAAG,CAACE,CAAC,CAAC;MACf,CAAC,MAAM;QACLD,OAAO,KAAKA,OAAO,GAAG,IAAI,CAAC;QAC3BD,GAAG,CAACE,CAAC,CAAC,GAAGG,GAAG;MACd;IACF;EACF;EAEA,OAAON,QAAQ,IAAI,CAAC3B,YAAY,GAAG6B,OAAO,IAAID,GAAG,GAAGA,GAAG;AACzD;AAEA,SAASzB,UAAU,CAAC+B,GAAG,EAAEnC,OAAO,EAAE;EAChC,MAAM6B,GAAG,GAAG,EAAE;EAEd,KAAK,MAAMO,IAAI,IAAID,GAAG,EAAE;IACtBN,GAAG,CAACQ,IAAI,CAACvC,KAAK,CAACsC,IAAI,EAAEpC,OAAO,EAAE,IAAI,CAAC,CAAC;EACtC;EAEA,OAAO6B,GAAG;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}