{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n  if (cast) {\n    let castOptions = {};\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n    this.$embeddedSchemaType = this.caster;\n  }\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n    break;\n  }\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const len = ret.length;\n    for (let i = 0; i < len; ++i) {\n      ret[i] = this.caster.applyGetters(ret[i], scope);\n    }\n  }\n  return ret;\n};\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n    options = options || emptyOpts;\n    value = MongooseArray(value, options.path || this._arrayPath || this.path, doc, this);\n    if (init && doc != null && doc.$__ != null && doc.populated(this.path)) {\n      return value;\n    }\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    const isArrayOfNumbers = caster.instance === 'Number';\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (isArrayOfNumbers && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          value[i] = caster.applySetters(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  if (Array.isArray(value)) {\n    let i;\n    const len = value.length;\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n          value[i] = caster.cast(value[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n  return val;\n};\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this, 'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n  return cast(this.casterConstructor.schema, val);\n}\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n    return ret;\n  };\n}\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","get","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","arr","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","populated","ret","len","length","i","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","valueDepth","min","max","containsNonArrayItem","prev","l","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substr","lastIndexOf","_arrayPath","isMongooseArray","isArrayOfNumbers","opts","arrayPathIndex","_arrayParentPath","applySetters","e","kind","inspect","markModified","_castForPopulate","discriminator","assign","schematype","validators","slice","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$regex","$nin","$in","module","exports"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const len = ret.length;\n    for (let i = 0; i < len; ++i) {\n      ret[i] = this.caster.applyGetters(ret[i], scope);\n    }\n  }\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    value = MongooseArray(value, options.path || this._arrayPath || this.path, doc, this);\n\n    if (init && doc != null && doc.$__ != null && doc.populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    const isArrayOfNumbers = caster.instance === 'Number';\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (isArrayOfNumbers && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          value[i] = caster.applySetters(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const len = value.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          value[i] = caster.cast(value[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this,\n    'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}