{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst normalizeRefPath = require('./normalizeRefPath');\nconst util = require('util');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let i;\n  let doc;\n  const len = docs.length;\n  const available = {};\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let Model;\n  let currentOptions;\n  let modelNames;\n  let modelName;\n  const originalModel = options.model;\n  let isVirtual = false;\n  const modelSchema = model.schema;\n  let allSchemaTypes = getSchemaTypes(modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const _firstWithRefPath = allSchemaTypes.find(schematype => get(schematype, 'options.refPath', null) != null);\n  for (i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    schema = getSchemaTypes(modelSchema, doc, options.path);\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    // Populating a nested path should always be a no-op re: #9073.\n    // People shouldn't do this, but apparently they do.\n    if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = !!_firstWithRefPath;\n    let normalizedRefPath = _firstWithRefPath ? get(_firstWithRefPath, 'options.refPath', null) : null;\n    let schemaOptions = null;\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizeRefPath(normalizedRefPath, doc, options.path) || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const _virtualRes = getVirtual(model.schema, options.path);\n    const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n    let localField;\n    let count = false;\n    if (virtual && virtual.options) {\n      const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n      if (typeof virtual.options.localField === 'function') {\n        localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n      } else if (Array.isArray(virtual.options.localField)) {\n        localField = virtual.options.localField.map(field => virtualPrefix + field);\n      } else {\n        localField = virtualPrefix + virtual.options.localField;\n      }\n      count = virtual.options.count;\n      if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n        options.skip = virtual.options.skip;\n      }\n      if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n        options.limit = virtual.options.limit;\n      }\n      if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n        options.perDocumentLimit = virtual.options.perDocumentLimit;\n      }\n    } else {\n      localField = options.path;\n    }\n    let foreignField = virtual && virtual.options ? virtual.options.foreignField : '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (virtual && virtual.options && virtual.options.refPath) {\n      const normalizedRefPath = normalizeRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      isVirtual = true;\n      const refValue = utils.getValue(normalizedRefPath, doc);\n      modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    } else if (virtual && virtual.options && virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function') {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      isVirtual = true;\n      if (!modelNames) {\n        modelNames = [].concat(normalizedRef);\n      }\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path)) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    if (virtual && (!localField || !foreignField)) {\n      return new MongooseError('If you are populating a virtual, you must set the ' + 'localField and foreignField options');\n    }\n    options.isVirtual = isVirtual;\n    options.virtual = virtual;\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc);\n    }\n    let match = get(options, 'match', null) || get(currentOptions, 'match', null) || get(options, 'virtual.options.match', null) || get(options, 'virtual.options.options.match', null);\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    const localFieldPathType = modelSchema._getPathType(localField);\n    const localFieldPath = localFieldPathType === 'real' ? modelSchema.path(localField) : localFieldPathType.schema;\n    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n    let ret;\n    const _populateOptions = get(options, 'options', {});\n    const getters = 'getters' in _populateOptions ? _populateOptions.getters : options.isVirtual && get(virtual, 'options.getters', false);\n    if (localFieldGetters.length > 0 && getters) {\n      const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n      const localFieldValue = mpath.get(localField, doc, lookupLocalFields);\n      if (Array.isArray(localFieldValue)) {\n        const localFieldHydratedValue = mpath.get(localField.split('.').slice(0, -1), hydratedDoc, lookupLocalFields);\n        ret = localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n      } else {\n        ret = localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n      }\n    } else {\n      ret = convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n    }\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n    // out embedded discriminator docs that don't have a `refPath` on the\n    // populated path.\n    if (isRefPath && normalizedRefPath != null) {\n      const pieces = normalizedRefPath.split('.');\n      let cur = '';\n      for (let j = 0; j < pieces.length; ++j) {\n        const piece = pieces[j];\n        cur = cur + (cur.length === 0 ? '' : '.') + piece;\n        const schematype = modelSchema.path(cur);\n        if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length > 0) {\n          const subdocs = utils.getValue(cur, doc);\n          const remnant = options.path.substr(cur.length + 1);\n          const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n          modelNames = [];\n          for (const subdoc of subdocs) {\n            const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n            const discriminator = schematype.caster.discriminators[discriminatorName];\n            const discriminatorSchema = discriminator && discriminator.schema;\n            if (discriminatorSchema == null) {\n              continue;\n            }\n            const _path = discriminatorSchema.path(remnant);\n            if (_path == null || _path.options.refPath == null) {\n              const docValue = utils.getValue(localField.substr(cur.length + 1), subdoc);\n              ret = ret.map(v => v === docValue ? SkipPopulateValue(v) : v);\n              continue;\n            }\n            const modelName = utils.getValue(pieces.slice(j + 1).join('.'), subdoc);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    }\n    let k = modelNames.length;\n    while (k--) {\n      modelName = modelNames[k];\n      if (modelName == null) {\n        continue;\n      }\n\n      // `PopulateOptions#connection`: if the model is passed as a string, the\n      // connection matters because different connections have different models.\n      const connection = options.connection != null ? options.connection : model.db;\n      try {\n        Model = originalModel && originalModel[modelSymbol] ? originalModel : modelName[modelSymbol] ? modelName : connection.model(modelName);\n      } catch (error) {\n        // If `ret` is undefined, we'll add an empty entry to modelsMap. We shouldn't\n        // execute a query, but it is necessary to make sure `justOne` gets handled\n        // correctly for setting an empty array (see gh-8455)\n        if (ret !== undefined) {\n          return error;\n        }\n      }\n      let ids = ret;\n      const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n      if (isRefPath && Array.isArray(ret) && flat.length === modelNames.length) {\n        ids = flat.filter((val, i) => modelNames[i] === modelName);\n      }\n      if (!available[modelName] || currentOptions.perDocumentLimit != null || get(currentOptions, 'options.perDocumentLimit') != null) {\n        currentOptions = {\n          model: Model\n        };\n        if (isVirtual && get(virtual, 'options.options')) {\n          currentOptions.options = utils.clone(virtual.options.options);\n        } else if (schemaOptions != null) {\n          currentOptions.options = Object.assign({}, schemaOptions);\n        }\n        utils.merge(currentOptions, options);\n\n        // Used internally for checking what model was used to populate this\n        // path.\n        options[populateModelSymbol] = Model;\n        available[modelName] = {\n          model: Model,\n          options: currentOptions,\n          match: hasMatchFunction ? [match] : match,\n          docs: [doc],\n          ids: [ids],\n          allIds: [ret],\n          localField: new Set([localField]),\n          foreignField: new Set([foreignField]),\n          justOne: justOne,\n          isVirtual: isVirtual,\n          virtual: virtual,\n          count: count,\n          [populateModelSymbol]: Model\n        };\n        map.push(available[modelName]);\n      } else {\n        available[modelName].localField.add(localField);\n        available[modelName].foreignField.add(foreignField);\n        available[modelName].docs.push(doc);\n        available[modelName].ids.push(ids);\n        available[modelName].allIds.push(ret);\n        if (hasMatchFunction) {\n          available[modelName].match.push(match);\n        }\n      }\n    }\n  }\n  return map;\n  function _getModelNames(doc, schema) {\n    let modelNames;\n    let discriminatorKey;\n    let isRefPath = false;\n    let justOne = null;\n    if (schema && schema.caster) {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n    if (!schema && model.discriminators) {\n      discriminatorKey = model.schema.discriminatorMapping.key;\n    }\n    refPath = schema && schema.options && schema.options.refPath;\n    const normalizedRefPath = normalizeRefPath(refPath, doc, options.path);\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (normalizedRefPath) {\n      if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {\n        throw new MongooseError('refPath `' + normalizedRefPath + '` must not be excluded in projection, got ' + util.inspect(options._queryProjection));\n      }\n      if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc.$__ == null) {\n        modelNames = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc)];\n      } else {\n        modelNames = utils.getValue(normalizedRefPath, doc);\n      }\n      if (Array.isArray(modelNames)) {\n        modelNames = utils.array.flatten(modelNames);\n      }\n      isRefPath = true;\n    } else {\n      let modelForCurrentDoc = model;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = model.db.model(discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      const _virtualRes = getVirtual(modelForCurrentDoc.schema, options.path);\n      const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n      if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      let ref;\n      let refPath;\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        ref = handleRefFunction(ref, doc);\n        modelNames = [ref];\n      } else if ((ref = get(virtual, 'options.ref')) != null) {\n        ref = handleRefFunction(ref, doc);\n\n        // When referencing nested arrays, the ref should be an Array\n        // of modelNames.\n        if (Array.isArray(ref)) {\n          modelNames = ref;\n        } else {\n          modelNames = [ref];\n        }\n        isVirtual = true;\n      } else if ((refPath = get(schemaForCurrentDoc, 'options.refPath')) != null) {\n        isRefPath = true;\n        refPath = normalizeRefPath(refPath, doc, options.path);\n        modelNames = utils.getValue(refPath, doc);\n        if (Array.isArray(modelNames)) {\n          modelNames = utils.array.flatten(modelNames);\n        }\n      } else {\n        // We may have a discriminator, in which case we don't want to\n        // populate using the base model by default\n        modelNames = discriminatorKey ? null : [model.modelName];\n      }\n    }\n    if (!modelNames) {\n      return {\n        modelNames: modelNames,\n        isRefPath: isRefPath,\n        refPath: normalizedRefPath,\n        justOne: justOne\n      };\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      isRefPath: isRefPath,\n      refPath: normalizedRefPath,\n      justOne: justOne\n    };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    for (let i = 0; i < val.length; ++i) {\n      if (val[i] != null && val[i].$__ != null) {\n        val[i] = val[i]._id;\n      }\n    }\n    if (val.isMongooseArray && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' && (\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map').execPopulate()`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","get","getDiscriminatorByValue","isPathExcluded","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","normalizeRefPath","util","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","module","exports","getModelsMapForPopulate","model","docs","options","i","doc","len","length","available","map","modelNameFromQuery","modelName","schema","refPath","Model","currentOptions","modelNames","originalModel","isVirtual","modelSchema","allSchemaTypes","path","Array","isArray","filter","v","_firstWithRefPath","find","schematype","justOne","$isMongooseDocumentArray","ref","_localModel","nested","isUnderneathDocArray","$isUnderneathDocArray","isRefPath","normalizedRefPath","schemaOptions","schemasArray","_schema","_modelNames","res","_getModelNames","error","indexOf","push","_virtualRes","virtual","localField","count","virtualPrefix","nestedSchemaPath","call","field","skip","hasOwnProperty","limit","perDocumentLimit","foreignField","refValue","getValue","normalizedRef","concat","endsWith","every","$isMongooseArray","match","hasMatchFunction","Object","assign","convertTo_id","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","ret","_populateOptions","hydratedDoc","$__","hydrate","localFieldValue","localFieldHydratedValue","split","slice","localFieldArrVal","localFieldArrIndex","applyGetters","id","String","_docs","pieces","cur","j","piece","caster","discriminators","keys","subdocs","remnant","substr","discriminatorKey","subdoc","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join","k","connection","db","undefined","ids","flat","array","flatten","val","clone","merge","allIds","Set","add","$isSchemaMap","$__schemaType","discriminatorMapping","key","_queryProjection","inspect","virtuals","modelForCurrentDoc","schemaForCurrentDoc","discriminatorValue","discriminatorModel","_getSchema","_arrayPath","handleRefFunction","_id","isMongooseArray","$schema","_castForPopulate","$parent","Map","from","values"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst normalizeRefPath = require('./normalizeRefPath');\nconst util = require('util');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let i;\n  let doc;\n  const len = docs.length;\n  const available = {};\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let Model;\n  let currentOptions;\n  let modelNames;\n  let modelName;\n\n  const originalModel = options.model;\n  let isVirtual = false;\n  const modelSchema = model.schema;\n\n  let allSchemaTypes = getSchemaTypes(modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const _firstWithRefPath = allSchemaTypes.find(schematype => get(schematype, 'options.refPath', null) != null);\n\n  for (i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    schema = getSchemaTypes(modelSchema, doc, options.path);\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    // Populating a nested path should always be a no-op re: #9073.\n    // People shouldn't do this, but apparently they do.\n    if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = !!_firstWithRefPath;\n    let normalizedRefPath = _firstWithRefPath ? get(_firstWithRefPath, 'options.refPath', null) : null;\n    let schemaOptions = null;\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizeRefPath(normalizedRefPath, doc, options.path) ||\n            res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const _virtualRes = getVirtual(model.schema, options.path);\n    const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n\n    let localField;\n    let count = false;\n    if (virtual && virtual.options) {\n      const virtualPrefix = _virtualRes.nestedSchemaPath ?\n        _virtualRes.nestedSchemaPath + '.' : '';\n      if (typeof virtual.options.localField === 'function') {\n        localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n      } else if (Array.isArray(virtual.options.localField)) {\n        localField = virtual.options.localField.map(field => virtualPrefix + field);\n      } else {\n        localField = virtualPrefix + virtual.options.localField;\n      }\n      count = virtual.options.count;\n\n      if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n        options.skip = virtual.options.skip;\n      }\n      if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n        options.limit = virtual.options.limit;\n      }\n      if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n        options.perDocumentLimit = virtual.options.perDocumentLimit;\n      }\n    } else {\n      localField = options.path;\n    }\n    let foreignField = virtual && virtual.options ?\n      virtual.options.foreignField :\n      '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (virtual && virtual.options && virtual.options.refPath) {\n      const normalizedRefPath =\n        normalizeRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      isVirtual = true;\n      const refValue = utils.getValue(normalizedRefPath, doc);\n      modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    } else if (virtual && virtual.options && virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function') {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      isVirtual = true;\n      if (!modelNames) {\n        modelNames = [].concat(normalizedRef);\n      }\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path)) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    if (virtual && (!localField || !foreignField)) {\n      return new MongooseError('If you are populating a virtual, you must set the ' +\n        'localField and foreignField options');\n    }\n\n    options.isVirtual = isVirtual;\n    options.virtual = virtual;\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc);\n    }\n\n    let match = get(options, 'match', null) ||\n      get(currentOptions, 'match', null) ||\n      get(options, 'virtual.options.match', null) ||\n      get(options, 'virtual.options.options.match', null);\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n\n    const localFieldPathType = modelSchema._getPathType(localField);\n    const localFieldPath = localFieldPathType === 'real' ? modelSchema.path(localField) : localFieldPathType.schema;\n    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n    let ret;\n\n    const _populateOptions = get(options, 'options', {});\n\n    const getters = 'getters' in _populateOptions ?\n      _populateOptions.getters :\n      options.isVirtual && get(virtual, 'options.getters', false);\n    if (localFieldGetters.length > 0 && getters) {\n      const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n      const localFieldValue = mpath.get(localField, doc, lookupLocalFields);\n      if (Array.isArray(localFieldValue)) {\n        const localFieldHydratedValue = mpath.get(localField.split('.').slice(0, -1), hydratedDoc, lookupLocalFields);\n        ret = localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n          localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n      } else {\n        ret = localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n      }\n    } else {\n      ret = convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n    }\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n    // out embedded discriminator docs that don't have a `refPath` on the\n    // populated path.\n    if (isRefPath && normalizedRefPath != null) {\n      const pieces = normalizedRefPath.split('.');\n      let cur = '';\n      for (let j = 0; j < pieces.length; ++j) {\n        const piece = pieces[j];\n        cur = cur + (cur.length === 0 ? '' : '.') + piece;\n        const schematype = modelSchema.path(cur);\n        if (schematype != null &&\n            schematype.$isMongooseArray &&\n            schematype.caster.discriminators != null &&\n            Object.keys(schematype.caster.discriminators).length > 0) {\n          const subdocs = utils.getValue(cur, doc);\n          const remnant = options.path.substr(cur.length + 1);\n          const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n          modelNames = [];\n          for (const subdoc of subdocs) {\n            const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n            const discriminator = schematype.caster.discriminators[discriminatorName];\n            const discriminatorSchema = discriminator && discriminator.schema;\n            if (discriminatorSchema == null) {\n              continue;\n            }\n            const _path = discriminatorSchema.path(remnant);\n            if (_path == null || _path.options.refPath == null) {\n              const docValue = utils.getValue(localField.substr(cur.length + 1), subdoc);\n              ret = ret.map(v => v === docValue ? SkipPopulateValue(v) : v);\n              continue;\n            }\n            const modelName = utils.getValue(pieces.slice(j + 1).join('.'), subdoc);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    }\n\n    let k = modelNames.length;\n    while (k--) {\n      modelName = modelNames[k];\n      if (modelName == null) {\n        continue;\n      }\n\n      // `PopulateOptions#connection`: if the model is passed as a string, the\n      // connection matters because different connections have different models.\n      const connection = options.connection != null ? options.connection : model.db;\n\n      try {\n        Model = originalModel && originalModel[modelSymbol] ?\n          originalModel :\n          modelName[modelSymbol] ? modelName : connection.model(modelName);\n      } catch (error) {\n        // If `ret` is undefined, we'll add an empty entry to modelsMap. We shouldn't\n        // execute a query, but it is necessary to make sure `justOne` gets handled\n        // correctly for setting an empty array (see gh-8455)\n        if (ret !== undefined) {\n          return error;\n        }\n      }\n\n      let ids = ret;\n      const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n      if (isRefPath && Array.isArray(ret) && flat.length === modelNames.length) {\n        ids = flat.filter((val, i) => modelNames[i] === modelName);\n      }\n\n      if (!available[modelName] || currentOptions.perDocumentLimit != null || get(currentOptions, 'options.perDocumentLimit') != null) {\n        currentOptions = {\n          model: Model\n        };\n\n        if (isVirtual && get(virtual, 'options.options')) {\n          currentOptions.options = utils.clone(virtual.options.options);\n        } else if (schemaOptions != null) {\n          currentOptions.options = Object.assign({}, schemaOptions);\n        }\n        utils.merge(currentOptions, options);\n\n        // Used internally for checking what model was used to populate this\n        // path.\n        options[populateModelSymbol] = Model;\n\n        available[modelName] = {\n          model: Model,\n          options: currentOptions,\n          match: hasMatchFunction ? [match] : match,\n          docs: [doc],\n          ids: [ids],\n          allIds: [ret],\n          localField: new Set([localField]),\n          foreignField: new Set([foreignField]),\n          justOne: justOne,\n          isVirtual: isVirtual,\n          virtual: virtual,\n          count: count,\n          [populateModelSymbol]: Model\n        };\n        map.push(available[modelName]);\n      } else {\n        available[modelName].localField.add(localField);\n        available[modelName].foreignField.add(foreignField);\n        available[modelName].docs.push(doc);\n        available[modelName].ids.push(ids);\n        available[modelName].allIds.push(ret);\n        if (hasMatchFunction) {\n          available[modelName].match.push(match);\n        }\n      }\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema) {\n    let modelNames;\n    let discriminatorKey;\n    let isRefPath = false;\n    let justOne = null;\n\n    if (schema && schema.caster) {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    if (!schema && model.discriminators) {\n      discriminatorKey = model.schema.discriminatorMapping.key;\n    }\n\n    refPath = schema && schema.options && schema.options.refPath;\n\n    const normalizedRefPath = normalizeRefPath(refPath, doc, options.path);\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (normalizedRefPath) {\n      if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {\n        throw new MongooseError('refPath `' + normalizedRefPath +\n          '` must not be excluded in projection, got ' +\n          util.inspect(options._queryProjection));\n      }\n\n      if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc.$__ == null) {\n        modelNames = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc)];\n      } else {\n        modelNames = utils.getValue(normalizedRefPath, doc);\n      }\n\n      if (Array.isArray(modelNames)) {\n        modelNames = utils.array.flatten(modelNames);\n      }\n\n      isRefPath = true;\n    } else {\n      let modelForCurrentDoc = model;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = model.db.model(discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      const _virtualRes = getVirtual(modelForCurrentDoc.schema, options.path);\n      const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n\n      if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      let ref;\n      let refPath;\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        ref = handleRefFunction(ref, doc);\n        modelNames = [ref];\n      } else if ((ref = get(virtual, 'options.ref')) != null) {\n        ref = handleRefFunction(ref, doc);\n\n        // When referencing nested arrays, the ref should be an Array\n        // of modelNames.\n        if (Array.isArray(ref)) {\n          modelNames = ref;\n        } else {\n          modelNames = [ref];\n        }\n\n        isVirtual = true;\n      } else if ((refPath = get(schemaForCurrentDoc, 'options.refPath')) != null) {\n        isRefPath = true;\n        refPath = normalizeRefPath(refPath, doc, options.path);\n        modelNames = utils.getValue(refPath, doc);\n        if (Array.isArray(modelNames)) {\n          modelNames = utils.array.flatten(modelNames);\n        }\n      } else {\n        // We may have a discriminator, in which case we don't want to\n        // populate using the base model by default\n        modelNames = discriminatorKey ? null : [model.modelName];\n      }\n    }\n\n    if (!modelNames) {\n      return { modelNames: modelNames, isRefPath: isRefPath, refPath: normalizedRefPath, justOne: justOne };\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, isRefPath: isRefPath, refPath: normalizedRefPath, justOne: justOne };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    for (let i = 0; i < val.length; ++i) {\n      if (val[i] != null && val[i].$__ != null) {\n        val[i] = val[i]._id;\n      }\n    }\n    if (val.isMongooseArray && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map').execPopulate()`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,aAAa,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAClD,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAME,GAAG,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC7B,MAAMG,uBAAuB,GAAGH,OAAO,CAAC,0CAA0C,CAAC;AACnF,MAAMI,cAAc,GAAGJ,OAAO,CAAC,8BAA8B,CAAC;AAC9D,MAAMK,kBAAkB,GAAGL,OAAO,CAAC,uBAAuB,CAAC;AAC3D,MAAMM,cAAc,GAAGN,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAMO,UAAU,GAAGP,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAMQ,iBAAiB,GAAGR,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAMS,KAAK,GAAGT,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMU,gBAAgB,GAAGV,OAAO,CAAC,oBAAoB,CAAC;AACtD,MAAMW,IAAI,GAAGX,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMY,KAAK,GAAGZ,OAAO,CAAC,aAAa,CAAC;AAEpC,MAAMa,WAAW,GAAGb,OAAO,CAAC,YAAY,CAAC,CAACa,WAAW;AACrD,MAAMC,mBAAmB,GAAGd,OAAO,CAAC,YAAY,CAAC,CAACc,mBAAmB;AACrE,MAAMC,iBAAiB,GAAGf,OAAO,CAAC,sBAAsB,CAAC,CAACe,iBAAiB;AAE3EC,MAAM,CAACC,OAAO,GAAG,SAASC,uBAAuB,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;EACtE,IAAIC,CAAC;EACL,IAAIC,GAAG;EACP,MAAMC,GAAG,GAAGJ,IAAI,CAACK,MAAM;EACvB,MAAMC,SAAS,GAAG,CAAC,CAAC;EACpB,MAAMC,GAAG,GAAG,EAAE;EACd,MAAMC,kBAAkB,GAAGP,OAAO,CAACF,KAAK,IAAIE,OAAO,CAACF,KAAK,CAACU,SAAS,IAAIR,OAAO,CAACF,KAAK;EACpF,IAAIW,MAAM;EACV,IAAIC,OAAO;EACX,IAAIC,KAAK;EACT,IAAIC,cAAc;EAClB,IAAIC,UAAU;EACd,IAAIL,SAAS;EAEb,MAAMM,aAAa,GAAGd,OAAO,CAACF,KAAK;EACnC,IAAIiB,SAAS,GAAG,KAAK;EACrB,MAAMC,WAAW,GAAGlB,KAAK,CAACW,MAAM;EAEhC,IAAIQ,cAAc,GAAGhC,cAAc,CAAC+B,WAAW,EAAE,IAAI,EAAEhB,OAAO,CAACkB,IAAI,CAAC;EACpED,cAAc,GAAGE,KAAK,CAACC,OAAO,CAACH,cAAc,CAAC,GAAGA,cAAc,GAAG,CAACA,cAAc,CAAC,CAACI,MAAM,CAACC,CAAC,IAAIA,CAAC,IAAI,IAAI,CAAC;EACzG,MAAMC,iBAAiB,GAAGN,cAAc,CAACO,IAAI,CAACC,UAAU,IAAI5C,GAAG,CAAC4C,UAAU,EAAE,iBAAiB,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC;EAE7G,KAAKxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,GAAG,EAAEF,CAAC,EAAE,EAAE;IACxBC,GAAG,GAAGH,IAAI,CAACE,CAAC,CAAC;IACb,IAAIyB,OAAO,GAAG,IAAI;IAClBjB,MAAM,GAAGxB,cAAc,CAAC+B,WAAW,EAAEd,GAAG,EAAEF,OAAO,CAACkB,IAAI,CAAC;IACvD;IACA;IACA,IAAIT,MAAM,IAAI,IAAI,IACdA,MAAM,CAACkB,wBAAwB,IAC/BlB,MAAM,CAACT,OAAO,CAAC4B,GAAG,IAAI,IAAI,IAC1BnB,MAAM,CAACT,OAAO,CAACU,OAAO,IAAI,IAAI,EAAE;MAClC;IACF;IACA;IACA;IACA,IAAIV,OAAO,CAAC6B,WAAW,IAAI,IAAI,IAAI7B,OAAO,CAAC6B,WAAW,CAACpB,MAAM,CAACqB,MAAM,CAAC9B,OAAO,CAACkB,IAAI,CAAC,EAAE;MAClF;IACF;IACA,MAAMa,oBAAoB,GAAGtB,MAAM,IAAIA,MAAM,CAACuB,qBAAqB;IACnE,IAAID,oBAAoB,IAAIlD,GAAG,CAACmB,OAAO,EAAE,cAAc,CAAC,IAAI,IAAI,EAAE;MAChE,OAAO,IAAItB,aAAa,CAAC,sCAAsC,GAAGsB,OAAO,CAACkB,IAAI,GAC5E,kDAAkD,CAAC;IACvD;IAEAL,UAAU,GAAG,IAAI;IACjB,IAAIoB,SAAS,GAAG,CAAC,CAACV,iBAAiB;IACnC,IAAIW,iBAAiB,GAAGX,iBAAiB,GAAG1C,GAAG,CAAC0C,iBAAiB,EAAE,iBAAiB,EAAE,IAAI,CAAC,GAAG,IAAI;IAClG,IAAIY,aAAa,GAAG,IAAI;IAExB,IAAIhB,KAAK,CAACC,OAAO,CAACX,MAAM,CAAC,EAAE;MACzB,MAAM2B,YAAY,GAAG3B,MAAM;MAC3B,KAAK,MAAM4B,OAAO,IAAID,YAAY,EAAE;QAClC,IAAIE,WAAW;QACf,IAAIC,GAAG;QACP,IAAI;UACFA,GAAG,GAAGC,cAAc,CAACtC,GAAG,EAAEmC,OAAO,CAAC;UAClCC,WAAW,GAAGC,GAAG,CAAC1B,UAAU;UAC5BoB,SAAS,GAAGA,SAAS,IAAIM,GAAG,CAACN,SAAS;UACtCC,iBAAiB,GAAG7C,gBAAgB,CAAC6C,iBAAiB,EAAEhC,GAAG,EAAEF,OAAO,CAACkB,IAAI,CAAC,IACxEqB,GAAG,CAAC7B,OAAO;UACbgB,OAAO,GAAGa,GAAG,CAACb,OAAO;QACvB,CAAC,CAAC,OAAOe,KAAK,EAAE;UACd,OAAOA,KAAK;QACd;QAEA,IAAIR,SAAS,IAAI,CAACM,GAAG,CAACN,SAAS,EAAE;UAC/B;QACF;QACA,IAAI,CAACK,WAAW,EAAE;UAChB;QACF;QACAzB,UAAU,GAAGA,UAAU,IAAI,EAAE;QAC7B,KAAK,MAAML,SAAS,IAAI8B,WAAW,EAAE;UACnC,IAAIzB,UAAU,CAAC6B,OAAO,CAAClC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;YACxCK,UAAU,CAAC8B,IAAI,CAACnC,SAAS,CAAC;UAC5B;QACF;MACF;IACF,CAAC,MAAM;MACL,IAAI;QACF,MAAM+B,GAAG,GAAGC,cAAc,CAACtC,GAAG,EAAEO,MAAM,CAAC;QACvCI,UAAU,GAAG0B,GAAG,CAAC1B,UAAU;QAC3BoB,SAAS,GAAGM,GAAG,CAACN,SAAS;QACzBC,iBAAiB,GAAGK,GAAG,CAAC7B,OAAO;QAC/BgB,OAAO,GAAGa,GAAG,CAACb,OAAO;QACrBS,aAAa,GAAGtD,GAAG,CAAC4B,MAAM,EAAE,kBAAkB,EAAE,IAAI,CAAC;MACvD,CAAC,CAAC,OAAOgC,KAAK,EAAE;QACd,OAAOA,KAAK;MACd;MAEA,IAAI,CAAC5B,UAAU,EAAE;QACf;MACF;IACF;IAEA,MAAM+B,WAAW,GAAG1D,UAAU,CAACY,KAAK,CAACW,MAAM,EAAET,OAAO,CAACkB,IAAI,CAAC;IAC1D,MAAM2B,OAAO,GAAGD,WAAW,IAAI,IAAI,GAAG,IAAI,GAAGA,WAAW,CAACC,OAAO;IAEhE,IAAIC,UAAU;IACd,IAAIC,KAAK,GAAG,KAAK;IACjB,IAAIF,OAAO,IAAIA,OAAO,CAAC7C,OAAO,EAAE;MAC9B,MAAMgD,aAAa,GAAGJ,WAAW,CAACK,gBAAgB,GAChDL,WAAW,CAACK,gBAAgB,GAAG,GAAG,GAAG,EAAE;MACzC,IAAI,OAAOJ,OAAO,CAAC7C,OAAO,CAAC8C,UAAU,KAAK,UAAU,EAAE;QACpDA,UAAU,GAAGE,aAAa,GAAGH,OAAO,CAAC7C,OAAO,CAAC8C,UAAU,CAACI,IAAI,CAAChD,GAAG,EAAEA,GAAG,CAAC;MACxE,CAAC,MAAM,IAAIiB,KAAK,CAACC,OAAO,CAACyB,OAAO,CAAC7C,OAAO,CAAC8C,UAAU,CAAC,EAAE;QACpDA,UAAU,GAAGD,OAAO,CAAC7C,OAAO,CAAC8C,UAAU,CAACxC,GAAG,CAAC6C,KAAK,IAAIH,aAAa,GAAGG,KAAK,CAAC;MAC7E,CAAC,MAAM;QACLL,UAAU,GAAGE,aAAa,GAAGH,OAAO,CAAC7C,OAAO,CAAC8C,UAAU;MACzD;MACAC,KAAK,GAAGF,OAAO,CAAC7C,OAAO,CAAC+C,KAAK;MAE7B,IAAIF,OAAO,CAAC7C,OAAO,CAACoD,IAAI,IAAI,IAAI,IAAI,CAACpD,OAAO,CAACqD,cAAc,CAAC,MAAM,CAAC,EAAE;QACnErD,OAAO,CAACoD,IAAI,GAAGP,OAAO,CAAC7C,OAAO,CAACoD,IAAI;MACrC;MACA,IAAIP,OAAO,CAAC7C,OAAO,CAACsD,KAAK,IAAI,IAAI,IAAI,CAACtD,OAAO,CAACqD,cAAc,CAAC,OAAO,CAAC,EAAE;QACrErD,OAAO,CAACsD,KAAK,GAAGT,OAAO,CAAC7C,OAAO,CAACsD,KAAK;MACvC;MACA,IAAIT,OAAO,CAAC7C,OAAO,CAACuD,gBAAgB,IAAI,IAAI,IAAI,CAACvD,OAAO,CAACqD,cAAc,CAAC,kBAAkB,CAAC,EAAE;QAC3FrD,OAAO,CAACuD,gBAAgB,GAAGV,OAAO,CAAC7C,OAAO,CAACuD,gBAAgB;MAC7D;IACF,CAAC,MAAM;MACLT,UAAU,GAAG9C,OAAO,CAACkB,IAAI;IAC3B;IACA,IAAIsC,YAAY,GAAGX,OAAO,IAAIA,OAAO,CAAC7C,OAAO,GAC3C6C,OAAO,CAAC7C,OAAO,CAACwD,YAAY,GAC5B,KAAK;;IAEP;IACA;IACA;IACA,IAAI,SAAS,IAAIxD,OAAO,IAAIA,OAAO,CAAC0B,OAAO,KAAK,KAAK,CAAC,EAAE;MACtDA,OAAO,GAAG1B,OAAO,CAAC0B,OAAO;IAC3B,CAAC,MAAM,IAAImB,OAAO,IAAIA,OAAO,CAAC7C,OAAO,IAAI6C,OAAO,CAAC7C,OAAO,CAACU,OAAO,EAAE;MAChE,MAAMwB,iBAAiB,GACrB7C,gBAAgB,CAACwD,OAAO,CAAC7C,OAAO,CAACU,OAAO,EAAER,GAAG,EAAEF,OAAO,CAACkB,IAAI,CAAC;MAC9DQ,OAAO,GAAG,CAAC,CAACmB,OAAO,CAAC7C,OAAO,CAAC0B,OAAO;MACnCX,SAAS,GAAG,IAAI;MAChB,MAAM0C,QAAQ,GAAGlE,KAAK,CAACmE,QAAQ,CAACxB,iBAAiB,EAAEhC,GAAG,CAAC;MACvDW,UAAU,GAAGM,KAAK,CAACC,OAAO,CAACqC,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC;IAC9D,CAAC,MAAM,IAAIZ,OAAO,IAAIA,OAAO,CAAC7C,OAAO,IAAI6C,OAAO,CAAC7C,OAAO,CAAC4B,GAAG,EAAE;MAC5D,IAAI+B,aAAa;MACjB,IAAI,OAAOd,OAAO,CAAC7C,OAAO,CAAC4B,GAAG,KAAK,UAAU,EAAE;QAC7C+B,aAAa,GAAGd,OAAO,CAAC7C,OAAO,CAAC4B,GAAG,CAACsB,IAAI,CAAChD,GAAG,EAAEA,GAAG,CAAC;MACpD,CAAC,MAAM;QACLyD,aAAa,GAAGd,OAAO,CAAC7C,OAAO,CAAC4B,GAAG;MACrC;MACAF,OAAO,GAAG,CAAC,CAACmB,OAAO,CAAC7C,OAAO,CAAC0B,OAAO;MACnCX,SAAS,GAAG,IAAI;MAChB,IAAI,CAACF,UAAU,EAAE;QACfA,UAAU,GAAG,EAAE,CAAC+C,MAAM,CAACD,aAAa,CAAC;MACvC;IACF,CAAC,MAAM,IAAIlD,MAAM,IAAI,CAACA,MAAM,CAACf,iBAAiB,CAAC,EAAE;MAC/C;MACA,IAAIM,OAAO,CAACkB,IAAI,CAAC2C,QAAQ,CAAC,GAAG,GAAGpD,MAAM,CAACS,IAAI,CAAC,EAAE;QAC5CQ,OAAO,GAAGP,KAAK,CAACC,OAAO,CAACX,MAAM,CAAC,GAC7BA,MAAM,CAACqD,KAAK,CAACrD,MAAM,IAAI,CAACA,MAAM,CAACsD,gBAAgB,CAAC,GAChD,CAACtD,MAAM,CAACsD,gBAAgB;MAC5B;IACF;IAEA,IAAI,CAAClD,UAAU,EAAE;MACf;IACF;IAEA,IAAIgC,OAAO,KAAK,CAACC,UAAU,IAAI,CAACU,YAAY,CAAC,EAAE;MAC7C,OAAO,IAAI9E,aAAa,CAAC,oDAAoD,GAC3E,qCAAqC,CAAC;IAC1C;IAEAsB,OAAO,CAACe,SAAS,GAAGA,SAAS;IAC7Bf,OAAO,CAAC6C,OAAO,GAAGA,OAAO;IACzB,IAAI,OAAOC,UAAU,KAAK,UAAU,EAAE;MACpCA,UAAU,GAAGA,UAAU,CAACI,IAAI,CAAChD,GAAG,EAAEA,GAAG,CAAC;IACxC;IACA,IAAI,OAAOsD,YAAY,KAAK,UAAU,EAAE;MACtCA,YAAY,GAAGA,YAAY,CAACN,IAAI,CAAChD,GAAG,CAAC;IACvC;IAEA,IAAI8D,KAAK,GAAGnF,GAAG,CAACmB,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,IACrCnB,GAAG,CAAC+B,cAAc,EAAE,OAAO,EAAE,IAAI,CAAC,IAClC/B,GAAG,CAACmB,OAAO,EAAE,uBAAuB,EAAE,IAAI,CAAC,IAC3CnB,GAAG,CAACmB,OAAO,EAAE,+BAA+B,EAAE,IAAI,CAAC;IAErD,IAAIiE,gBAAgB,GAAG,OAAOD,KAAK,KAAK,UAAU;IAClD,IAAIC,gBAAgB,EAAE;MACpBD,KAAK,GAAGA,KAAK,CAACd,IAAI,CAAChD,GAAG,EAAEA,GAAG,CAAC;IAC9B;IAEA,IAAIiB,KAAK,CAACC,OAAO,CAAC0B,UAAU,CAAC,IAAI3B,KAAK,CAACC,OAAO,CAACoC,YAAY,CAAC,IAAIV,UAAU,CAAC1C,MAAM,KAAKoD,YAAY,CAACpD,MAAM,EAAE;MACzG4D,KAAK,GAAGE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,KAAK,CAAC;MAChC,KAAK,IAAI/D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,UAAU,CAAC1C,MAAM,EAAE,EAAEH,CAAC,EAAE;QAC1C+D,KAAK,CAACR,YAAY,CAACvD,CAAC,CAAC,CAAC,GAAGmE,YAAY,CAAChF,KAAK,CAACP,GAAG,CAACiE,UAAU,CAAC7C,CAAC,CAAC,EAAEC,GAAG,EAAEf,iBAAiB,CAAC,EAAEsB,MAAM,CAAC;QAC/FwD,gBAAgB,GAAG,IAAI;MACzB;MAEAnB,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC;MAC1BU,YAAY,GAAGA,YAAY,CAAC,CAAC,CAAC;IAChC;IAEA,MAAMa,kBAAkB,GAAGrD,WAAW,CAACsD,YAAY,CAACxB,UAAU,CAAC;IAC/D,MAAMyB,cAAc,GAAGF,kBAAkB,KAAK,MAAM,GAAGrD,WAAW,CAACE,IAAI,CAAC4B,UAAU,CAAC,GAAGuB,kBAAkB,CAAC5D,MAAM;IAC/G,MAAM+D,iBAAiB,GAAGD,cAAc,IAAIA,cAAc,CAACE,OAAO,GAAGF,cAAc,CAACE,OAAO,GAAG,EAAE;IAChG,IAAIC,GAAG;IAEP,MAAMC,gBAAgB,GAAG9F,GAAG,CAACmB,OAAO,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;IAEpD,MAAMyE,OAAO,GAAG,SAAS,IAAIE,gBAAgB,GAC3CA,gBAAgB,CAACF,OAAO,GACxBzE,OAAO,CAACe,SAAS,IAAIlC,GAAG,CAACgE,OAAO,EAAE,iBAAiB,EAAE,KAAK,CAAC;IAC7D,IAAI2B,iBAAiB,CAACpE,MAAM,GAAG,CAAC,IAAIqE,OAAO,EAAE;MAC3C,MAAMG,WAAW,GAAI1E,GAAG,CAAC2E,GAAG,IAAI,IAAI,GAAI3E,GAAG,GAAGJ,KAAK,CAACgF,OAAO,CAAC5E,GAAG,CAAC;MAChE,MAAM6E,eAAe,GAAG3F,KAAK,CAACP,GAAG,CAACiE,UAAU,EAAE5C,GAAG,EAAEf,iBAAiB,CAAC;MACrE,IAAIgC,KAAK,CAACC,OAAO,CAAC2D,eAAe,CAAC,EAAE;QAClC,MAAMC,uBAAuB,GAAG5F,KAAK,CAACP,GAAG,CAACiE,UAAU,CAACmC,KAAK,CAAC,GAAG,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEN,WAAW,EAAEzF,iBAAiB,CAAC;QAC7GuF,GAAG,GAAGK,eAAe,CAACzE,GAAG,CAAC,CAAC6E,gBAAgB,EAAEC,kBAAkB,KAC7Db,cAAc,CAACc,YAAY,CAACF,gBAAgB,EAAEH,uBAAuB,CAACI,kBAAkB,CAAC,CAAC,CAAC;MAC/F,CAAC,MAAM;QACLV,GAAG,GAAGH,cAAc,CAACc,YAAY,CAACN,eAAe,EAAEH,WAAW,CAAC;MACjE;IACF,CAAC,MAAM;MACLF,GAAG,GAAGN,YAAY,CAAChF,KAAK,CAACP,GAAG,CAACiE,UAAU,EAAE5C,GAAG,EAAEf,iBAAiB,CAAC,EAAEsB,MAAM,CAAC;IAC3E;IAEA,MAAM6E,EAAE,GAAGC,MAAM,CAAChG,KAAK,CAACmE,QAAQ,CAACF,YAAY,EAAEtD,GAAG,CAAC,CAAC;IACpDF,OAAO,CAACwF,KAAK,CAACF,EAAE,CAAC,GAAGnE,KAAK,CAACC,OAAO,CAACsD,GAAG,CAAC,GAAGA,GAAG,CAACQ,KAAK,EAAE,GAAGR,GAAG;;IAE1D;IACA;IACA;IACA,IAAIzC,SAAS,IAAIC,iBAAiB,IAAI,IAAI,EAAE;MAC1C,MAAMuD,MAAM,GAAGvD,iBAAiB,CAAC+C,KAAK,CAAC,GAAG,CAAC;MAC3C,IAAIS,GAAG,GAAG,EAAE;MACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACrF,MAAM,EAAE,EAAEuF,CAAC,EAAE;QACtC,MAAMC,KAAK,GAAGH,MAAM,CAACE,CAAC,CAAC;QACvBD,GAAG,GAAGA,GAAG,IAAIA,GAAG,CAACtF,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,GAAGwF,KAAK;QACjD,MAAMnE,UAAU,GAAGT,WAAW,CAACE,IAAI,CAACwE,GAAG,CAAC;QACxC,IAAIjE,UAAU,IAAI,IAAI,IAClBA,UAAU,CAACsC,gBAAgB,IAC3BtC,UAAU,CAACoE,MAAM,CAACC,cAAc,IAAI,IAAI,IACxC5B,MAAM,CAAC6B,IAAI,CAACtE,UAAU,CAACoE,MAAM,CAACC,cAAc,CAAC,CAAC1F,MAAM,GAAG,CAAC,EAAE;UAC5D,MAAM4F,OAAO,GAAGzG,KAAK,CAACmE,QAAQ,CAACgC,GAAG,EAAExF,GAAG,CAAC;UACxC,MAAM+F,OAAO,GAAGjG,OAAO,CAACkB,IAAI,CAACgF,MAAM,CAACR,GAAG,CAACtF,MAAM,GAAG,CAAC,CAAC;UACnD,MAAM+F,gBAAgB,GAAG1E,UAAU,CAACoE,MAAM,CAACpF,MAAM,CAACT,OAAO,CAACmG,gBAAgB;UAC1EtF,UAAU,GAAG,EAAE;UACf,KAAK,MAAMuF,MAAM,IAAIJ,OAAO,EAAE;YAC5B,MAAMK,iBAAiB,GAAG9G,KAAK,CAACmE,QAAQ,CAACyC,gBAAgB,EAAEC,MAAM,CAAC;YAClE,MAAME,aAAa,GAAG7E,UAAU,CAACoE,MAAM,CAACC,cAAc,CAACO,iBAAiB,CAAC;YACzE,MAAME,mBAAmB,GAAGD,aAAa,IAAIA,aAAa,CAAC7F,MAAM;YACjE,IAAI8F,mBAAmB,IAAI,IAAI,EAAE;cAC/B;YACF;YACA,MAAMC,KAAK,GAAGD,mBAAmB,CAACrF,IAAI,CAAC+E,OAAO,CAAC;YAC/C,IAAIO,KAAK,IAAI,IAAI,IAAIA,KAAK,CAACxG,OAAO,CAACU,OAAO,IAAI,IAAI,EAAE;cAClD,MAAM+F,QAAQ,GAAGlH,KAAK,CAACmE,QAAQ,CAACZ,UAAU,CAACoD,MAAM,CAACR,GAAG,CAACtF,MAAM,GAAG,CAAC,CAAC,EAAEgG,MAAM,CAAC;cAC1E1B,GAAG,GAAGA,GAAG,CAACpE,GAAG,CAACgB,CAAC,IAAIA,CAAC,KAAKmF,QAAQ,GAAG7H,iBAAiB,CAAC0C,CAAC,CAAC,GAAGA,CAAC,CAAC;cAC7D;YACF;YACA,MAAMd,SAAS,GAAGjB,KAAK,CAACmE,QAAQ,CAAC+B,MAAM,CAACP,KAAK,CAACS,CAAC,GAAG,CAAC,CAAC,CAACe,IAAI,CAAC,GAAG,CAAC,EAAEN,MAAM,CAAC;YACvEvF,UAAU,CAAC8B,IAAI,CAACnC,SAAS,CAAC;UAC5B;QACF;MACF;IACF;IAEA,IAAImG,CAAC,GAAG9F,UAAU,CAACT,MAAM;IACzB,OAAOuG,CAAC,EAAE,EAAE;MACVnG,SAAS,GAAGK,UAAU,CAAC8F,CAAC,CAAC;MACzB,IAAInG,SAAS,IAAI,IAAI,EAAE;QACrB;MACF;;MAEA;MACA;MACA,MAAMoG,UAAU,GAAG5G,OAAO,CAAC4G,UAAU,IAAI,IAAI,GAAG5G,OAAO,CAAC4G,UAAU,GAAG9G,KAAK,CAAC+G,EAAE;MAE7E,IAAI;QACFlG,KAAK,GAAGG,aAAa,IAAIA,aAAa,CAACtB,WAAW,CAAC,GACjDsB,aAAa,GACbN,SAAS,CAAChB,WAAW,CAAC,GAAGgB,SAAS,GAAGoG,UAAU,CAAC9G,KAAK,CAACU,SAAS,CAAC;MACpE,CAAC,CAAC,OAAOiC,KAAK,EAAE;QACd;QACA;QACA;QACA,IAAIiC,GAAG,KAAKoC,SAAS,EAAE;UACrB,OAAOrE,KAAK;QACd;MACF;MAEA,IAAIsE,GAAG,GAAGrC,GAAG;MACb,MAAMsC,IAAI,GAAG7F,KAAK,CAACC,OAAO,CAACsD,GAAG,CAAC,GAAGnF,KAAK,CAAC0H,KAAK,CAACC,OAAO,CAACxC,GAAG,CAAC,GAAG,EAAE;MAE/D,IAAIzC,SAAS,IAAId,KAAK,CAACC,OAAO,CAACsD,GAAG,CAAC,IAAIsC,IAAI,CAAC5G,MAAM,KAAKS,UAAU,CAACT,MAAM,EAAE;QACxE2G,GAAG,GAAGC,IAAI,CAAC3F,MAAM,CAAC,CAAC8F,GAAG,EAAElH,CAAC,KAAKY,UAAU,CAACZ,CAAC,CAAC,KAAKO,SAAS,CAAC;MAC5D;MAEA,IAAI,CAACH,SAAS,CAACG,SAAS,CAAC,IAAII,cAAc,CAAC2C,gBAAgB,IAAI,IAAI,IAAI1E,GAAG,CAAC+B,cAAc,EAAE,0BAA0B,CAAC,IAAI,IAAI,EAAE;QAC/HA,cAAc,GAAG;UACfd,KAAK,EAAEa;QACT,CAAC;QAED,IAAII,SAAS,IAAIlC,GAAG,CAACgE,OAAO,EAAE,iBAAiB,CAAC,EAAE;UAChDjC,cAAc,CAACZ,OAAO,GAAGT,KAAK,CAAC6H,KAAK,CAACvE,OAAO,CAAC7C,OAAO,CAACA,OAAO,CAAC;QAC/D,CAAC,MAAM,IAAImC,aAAa,IAAI,IAAI,EAAE;UAChCvB,cAAc,CAACZ,OAAO,GAAGkE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEhC,aAAa,CAAC;QAC3D;QACA5C,KAAK,CAAC8H,KAAK,CAACzG,cAAc,EAAEZ,OAAO,CAAC;;QAEpC;QACA;QACAA,OAAO,CAACP,mBAAmB,CAAC,GAAGkB,KAAK;QAEpCN,SAAS,CAACG,SAAS,CAAC,GAAG;UACrBV,KAAK,EAAEa,KAAK;UACZX,OAAO,EAAEY,cAAc;UACvBoD,KAAK,EAAEC,gBAAgB,GAAG,CAACD,KAAK,CAAC,GAAGA,KAAK;UACzCjE,IAAI,EAAE,CAACG,GAAG,CAAC;UACX6G,GAAG,EAAE,CAACA,GAAG,CAAC;UACVO,MAAM,EAAE,CAAC5C,GAAG,CAAC;UACb5B,UAAU,EAAE,IAAIyE,GAAG,CAAC,CAACzE,UAAU,CAAC,CAAC;UACjCU,YAAY,EAAE,IAAI+D,GAAG,CAAC,CAAC/D,YAAY,CAAC,CAAC;UACrC9B,OAAO,EAAEA,OAAO;UAChBX,SAAS,EAAEA,SAAS;UACpB8B,OAAO,EAAEA,OAAO;UAChBE,KAAK,EAAEA,KAAK;UACZ,CAACtD,mBAAmB,GAAGkB;QACzB,CAAC;QACDL,GAAG,CAACqC,IAAI,CAACtC,SAAS,CAACG,SAAS,CAAC,CAAC;MAChC,CAAC,MAAM;QACLH,SAAS,CAACG,SAAS,CAAC,CAACsC,UAAU,CAAC0E,GAAG,CAAC1E,UAAU,CAAC;QAC/CzC,SAAS,CAACG,SAAS,CAAC,CAACgD,YAAY,CAACgE,GAAG,CAAChE,YAAY,CAAC;QACnDnD,SAAS,CAACG,SAAS,CAAC,CAACT,IAAI,CAAC4C,IAAI,CAACzC,GAAG,CAAC;QACnCG,SAAS,CAACG,SAAS,CAAC,CAACuG,GAAG,CAACpE,IAAI,CAACoE,GAAG,CAAC;QAClC1G,SAAS,CAACG,SAAS,CAAC,CAAC8G,MAAM,CAAC3E,IAAI,CAAC+B,GAAG,CAAC;QACrC,IAAIT,gBAAgB,EAAE;UACpB5D,SAAS,CAACG,SAAS,CAAC,CAACwD,KAAK,CAACrB,IAAI,CAACqB,KAAK,CAAC;QACxC;MACF;IACF;EACF;EACA,OAAO1D,GAAG;EAEV,SAASkC,cAAc,CAACtC,GAAG,EAAEO,MAAM,EAAE;IACnC,IAAII,UAAU;IACd,IAAIsF,gBAAgB;IACpB,IAAIlE,SAAS,GAAG,KAAK;IACrB,IAAIP,OAAO,GAAG,IAAI;IAElB,IAAIjB,MAAM,IAAIA,MAAM,CAACoF,MAAM,EAAE;MAC3BpF,MAAM,GAAGA,MAAM,CAACoF,MAAM;IACxB;IACA,IAAIpF,MAAM,IAAIA,MAAM,CAACgH,YAAY,EAAE;MACjChH,MAAM,GAAGA,MAAM,CAACiH,aAAa;IAC/B;IAEA,IAAI,CAACjH,MAAM,IAAIX,KAAK,CAACgG,cAAc,EAAE;MACnCK,gBAAgB,GAAGrG,KAAK,CAACW,MAAM,CAACkH,oBAAoB,CAACC,GAAG;IAC1D;IAEAlH,OAAO,GAAGD,MAAM,IAAIA,MAAM,CAACT,OAAO,IAAIS,MAAM,CAACT,OAAO,CAACU,OAAO;IAE5D,MAAMwB,iBAAiB,GAAG7C,gBAAgB,CAACqB,OAAO,EAAER,GAAG,EAAEF,OAAO,CAACkB,IAAI,CAAC;IAEtE,IAAIX,kBAAkB,EAAE;MACtBM,UAAU,GAAG,CAACN,kBAAkB,CAAC,CAAC,CAAC;IACrC,CAAC,MAAM,IAAI2B,iBAAiB,EAAE;MAC5B,IAAIlC,OAAO,CAAC6H,gBAAgB,IAAI,IAAI,IAAI9I,cAAc,CAACiB,OAAO,CAAC6H,gBAAgB,EAAE3F,iBAAiB,CAAC,EAAE;QACnG,MAAM,IAAIxD,aAAa,CAAC,WAAW,GAAGwD,iBAAiB,GACrD,4CAA4C,GAC5C5C,IAAI,CAACwI,OAAO,CAAC9H,OAAO,CAAC6H,gBAAgB,CAAC,CAAC;MAC3C;MAEA,IAAI7G,WAAW,CAAC+G,QAAQ,CAAC1E,cAAc,CAACnB,iBAAiB,CAAC,IAAIhC,GAAG,CAAC2E,GAAG,IAAI,IAAI,EAAE;QAC7EhE,UAAU,GAAG,CAACG,WAAW,CAAC+G,QAAQ,CAAC7F,iBAAiB,CAAC,CAACmD,YAAY,CAAC,KAAK,CAAC,EAAEnF,GAAG,CAAC,CAAC;MAClF,CAAC,MAAM;QACLW,UAAU,GAAGtB,KAAK,CAACmE,QAAQ,CAACxB,iBAAiB,EAAEhC,GAAG,CAAC;MACrD;MAEA,IAAIiB,KAAK,CAACC,OAAO,CAACP,UAAU,CAAC,EAAE;QAC7BA,UAAU,GAAGtB,KAAK,CAAC0H,KAAK,CAACC,OAAO,CAACrG,UAAU,CAAC;MAC9C;MAEAoB,SAAS,GAAG,IAAI;IAClB,CAAC,MAAM;MACL,IAAI+F,kBAAkB,GAAGlI,KAAK;MAC9B,IAAImI,mBAAmB;MACvB,IAAIC,kBAAkB;MAEtB,IAAI,CAACzH,MAAM,IAAI0F,gBAAgB,KAAK+B,kBAAkB,GAAG3I,KAAK,CAACmE,QAAQ,CAACyC,gBAAgB,EAAEjG,GAAG,CAAC,CAAC,EAAE;QAC/F;QACA;QACA,MAAMiI,kBAAkB,GAAGrJ,uBAAuB,CAACgB,KAAK,CAACgG,cAAc,EAAEoC,kBAAkB,CAAC,IAAIpI,KAAK;QACrG,IAAIqI,kBAAkB,IAAI,IAAI,EAAE;UAC9BH,kBAAkB,GAAGG,kBAAkB;QACzC,CAAC,MAAM;UACL,IAAI;YACFH,kBAAkB,GAAGlI,KAAK,CAAC+G,EAAE,CAAC/G,KAAK,CAACoI,kBAAkB,CAAC;UACzD,CAAC,CAAC,OAAOzF,KAAK,EAAE;YACd,OAAOA,KAAK;UACd;QACF;QAEAwF,mBAAmB,GAAGD,kBAAkB,CAACvH,MAAM,CAAC2H,UAAU,CAACpI,OAAO,CAACkB,IAAI,CAAC;QAExE,IAAI+G,mBAAmB,IAAIA,mBAAmB,CAACpC,MAAM,EAAE;UACrDoC,mBAAmB,GAAGA,mBAAmB,CAACpC,MAAM;QAClD;MACF,CAAC,MAAM;QACLoC,mBAAmB,GAAGxH,MAAM;MAC9B;MACA,MAAMmC,WAAW,GAAG1D,UAAU,CAAC8I,kBAAkB,CAACvH,MAAM,EAAET,OAAO,CAACkB,IAAI,CAAC;MACvE,MAAM2B,OAAO,GAAGD,WAAW,IAAI,IAAI,GAAG,IAAI,GAAGA,WAAW,CAACC,OAAO;MAEhE,IAAIoF,mBAAmB,IAAI,IAAI,EAAE;QAC/BvG,OAAO,GAAG,CAACuG,mBAAmB,CAAClE,gBAAgB,IAAI,CAACkE,mBAAmB,CAACI,UAAU;MACpF;MAEA,IAAIzG,GAAG;MACP,IAAIlB,OAAO;MAEX,IAAI,CAACkB,GAAG,GAAG/C,GAAG,CAACoJ,mBAAmB,EAAE,aAAa,CAAC,KAAK,IAAI,EAAE;QAC3DrG,GAAG,GAAG0G,iBAAiB,CAAC1G,GAAG,EAAE1B,GAAG,CAAC;QACjCW,UAAU,GAAG,CAACe,GAAG,CAAC;MACpB,CAAC,MAAM,IAAI,CAACA,GAAG,GAAG/C,GAAG,CAACgE,OAAO,EAAE,aAAa,CAAC,KAAK,IAAI,EAAE;QACtDjB,GAAG,GAAG0G,iBAAiB,CAAC1G,GAAG,EAAE1B,GAAG,CAAC;;QAEjC;QACA;QACA,IAAIiB,KAAK,CAACC,OAAO,CAACQ,GAAG,CAAC,EAAE;UACtBf,UAAU,GAAGe,GAAG;QAClB,CAAC,MAAM;UACLf,UAAU,GAAG,CAACe,GAAG,CAAC;QACpB;QAEAb,SAAS,GAAG,IAAI;MAClB,CAAC,MAAM,IAAI,CAACL,OAAO,GAAG7B,GAAG,CAACoJ,mBAAmB,EAAE,iBAAiB,CAAC,KAAK,IAAI,EAAE;QAC1EhG,SAAS,GAAG,IAAI;QAChBvB,OAAO,GAAGrB,gBAAgB,CAACqB,OAAO,EAAER,GAAG,EAAEF,OAAO,CAACkB,IAAI,CAAC;QACtDL,UAAU,GAAGtB,KAAK,CAACmE,QAAQ,CAAChD,OAAO,EAAER,GAAG,CAAC;QACzC,IAAIiB,KAAK,CAACC,OAAO,CAACP,UAAU,CAAC,EAAE;UAC7BA,UAAU,GAAGtB,KAAK,CAAC0H,KAAK,CAACC,OAAO,CAACrG,UAAU,CAAC;QAC9C;MACF,CAAC,MAAM;QACL;QACA;QACAA,UAAU,GAAGsF,gBAAgB,GAAG,IAAI,GAAG,CAACrG,KAAK,CAACU,SAAS,CAAC;MAC1D;IACF;IAEA,IAAI,CAACK,UAAU,EAAE;MACf,OAAO;QAAEA,UAAU,EAAEA,UAAU;QAAEoB,SAAS,EAAEA,SAAS;QAAEvB,OAAO,EAAEwB,iBAAiB;QAAER,OAAO,EAAEA;MAAQ,CAAC;IACvG;IAEA,IAAI,CAACP,KAAK,CAACC,OAAO,CAACP,UAAU,CAAC,EAAE;MAC9BA,UAAU,GAAG,CAACA,UAAU,CAAC;IAC3B;IAEA,OAAO;MAAEA,UAAU,EAAEA,UAAU;MAAEoB,SAAS,EAAEA,SAAS;MAAEvB,OAAO,EAAEwB,iBAAiB;MAAER,OAAO,EAAEA;IAAQ,CAAC;EACvG;AACF,CAAC;;AAED;AACA;AACA;;AAEA,SAAS4G,iBAAiB,CAAC1G,GAAG,EAAE1B,GAAG,EAAE;EACnC,IAAI,OAAO0B,GAAG,KAAK,UAAU,IAAI,CAACA,GAAG,CAACpC,WAAW,CAAC,EAAE;IAClD,OAAOoC,GAAG,CAACsB,IAAI,CAAChD,GAAG,EAAEA,GAAG,CAAC;EAC3B;EACA,OAAO0B,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASwC,YAAY,CAAC+C,GAAG,EAAE1G,MAAM,EAAE;EACjC,IAAI0G,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACtC,GAAG,IAAI,IAAI,EAAE;IAClC,OAAOsC,GAAG,CAACoB,GAAG;EAChB;EACA,IAAIpB,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACoB,GAAG,IAAI,IAAI,KAAK9H,MAAM,IAAI,IAAI,IAAI,CAACA,MAAM,CAACgH,YAAY,CAAC,EAAE;IAC9E,OAAON,GAAG,CAACoB,GAAG;EAChB;EAEA,IAAIpH,KAAK,CAACC,OAAO,CAAC+F,GAAG,CAAC,EAAE;IACtB,KAAK,IAAIlH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkH,GAAG,CAAC/G,MAAM,EAAE,EAAEH,CAAC,EAAE;MACnC,IAAIkH,GAAG,CAAClH,CAAC,CAAC,IAAI,IAAI,IAAIkH,GAAG,CAAClH,CAAC,CAAC,CAAC4E,GAAG,IAAI,IAAI,EAAE;QACxCsC,GAAG,CAAClH,CAAC,CAAC,GAAGkH,GAAG,CAAClH,CAAC,CAAC,CAACsI,GAAG;MACrB;IACF;IACA,IAAIpB,GAAG,CAACqB,eAAe,IAAIrB,GAAG,CAACsB,OAAO,EAAE,EAAE;MACxC,OAAOtB,GAAG,CAACsB,OAAO,EAAE,CAACC,gBAAgB,CAACvB,GAAG,EAAEA,GAAG,CAACwB,OAAO,EAAE,CAAC;IAC3D;IAEA,OAAO,EAAE,CAAC/E,MAAM,CAACuD,GAAG,CAAC;EACvB;;EAEA;EACA;EACA,IAAInI,kBAAkB,CAACmI,GAAG,CAAC,KAAK,QAAQ;EACpC;EACA;EACC1G,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACf,iBAAiB,CAAC,IAAI,IAAI,CAAC,EAAE;IACzD,MAAMgF,GAAG,GAAG,EAAE;IACd,KAAK,MAAMkD,GAAG,IAAI1D,MAAM,CAAC6B,IAAI,CAACoB,GAAG,CAAC,EAAE;MAClCzC,GAAG,CAAC/B,IAAI,CAACwE,GAAG,CAACS,GAAG,CAAC,CAAC;IACpB;IACA,OAAOlD,GAAG;EACZ;EACA;EACA;EACA,IAAIyC,GAAG,YAAYyB,GAAG,EAAE;IACtB,OAAOzH,KAAK,CAAC0H,IAAI,CAAC1B,GAAG,CAAC2B,MAAM,EAAE,CAAC;EACjC;EAEA,OAAO3B,GAAG;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}