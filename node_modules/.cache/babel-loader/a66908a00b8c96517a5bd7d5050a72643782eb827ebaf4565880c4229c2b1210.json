{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.split('.');\n  let schema = null;\n  let type = 'adhocOrUndefined';\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schema = doc.schema.path(subpath);\n    if (schema == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schema.instance === 'Mixed') {\n      return typeOnly ? 'real' : schema;\n    }\n    type = doc.schema.pathType(subpath);\n    if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) && schema.schema.discriminators != null) {\n      const discriminators = schema.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' + get(schema, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schema;\n};","map":{"version":3,"names":["get","require","module","exports","getEmbeddedDiscriminatorPath","doc","path","options","typeOnly","parts","split","schema","type","i","length","subpath","slice","join","instance","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","discriminatorKey","rest"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.split('.');\n  let schema = null;\n  let type = 'adhocOrUndefined';\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schema = doc.schema.path(subpath);\n    if (schema == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schema.instance === 'Mixed') {\n      return typeOnly ? 'real' : schema;\n    }\n    type = doc.schema.pathType(subpath);\n    if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) &&\n        schema.schema.discriminators != null) {\n      const discriminators = schema.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schema, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schema;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE7B;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG,SAASC,4BAA4B,CAACC,GAAG,EAAEC,IAAI,EAAEC,OAAO,EAAE;EACzEA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMC,QAAQ,GAAGD,OAAO,CAACC,QAAQ;EACjC,MAAMC,KAAK,GAAGH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC;EAC7B,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIC,IAAI,GAAG,kBAAkB;EAE7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,MAAME,OAAO,GAAGN,KAAK,CAACO,KAAK,CAAC,CAAC,EAAEH,CAAC,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;IAC/CN,MAAM,GAAGN,GAAG,CAACM,MAAM,CAACL,IAAI,CAACS,OAAO,CAAC;IACjC,IAAIJ,MAAM,IAAI,IAAI,EAAE;MAClBC,IAAI,GAAG,kBAAkB;MACzB;IACF;IACA,IAAID,MAAM,CAACO,QAAQ,KAAK,OAAO,EAAE;MAC/B,OAAOV,QAAQ,GAAG,MAAM,GAAGG,MAAM;IACnC;IACAC,IAAI,GAAGP,GAAG,CAACM,MAAM,CAACQ,QAAQ,CAACJ,OAAO,CAAC;IACnC,IAAI,CAACJ,MAAM,CAACS,eAAe,IAAIT,MAAM,CAACU,+BAA+B,KACjEV,MAAM,CAACA,MAAM,CAACW,cAAc,IAAI,IAAI,EAAE;MACxC,MAAMA,cAAc,GAAGX,MAAM,CAACA,MAAM,CAACW,cAAc;MACnD,MAAMC,gBAAgB,GAAGlB,GAAG,CAACL,GAAG,CAACe,OAAO,GAAG,GAAG,GAC5Cf,GAAG,CAACW,MAAM,EAAE,iCAAiC,CAAC,CAAC;MACjD,IAAIY,gBAAgB,IAAI,IAAI,IAAID,cAAc,CAACC,gBAAgB,CAAC,IAAI,IAAI,EAAE;QACxE;MACF;MACA,MAAMC,IAAI,GAAGf,KAAK,CAACO,KAAK,CAACH,CAAC,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;MACzC,OAAOb,4BAA4B,CAACC,GAAG,CAACL,GAAG,CAACe,OAAO,CAAC,EAAES,IAAI,EAAEjB,OAAO,CAAC;IACtE;EACF;;EAEA;EACA,OAAOC,QAAQ,GAAGI,IAAI,GAAGD,MAAM;AACjC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}