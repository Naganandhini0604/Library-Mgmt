{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst utils = require('./utils');\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function () {\n  const states = utils.args(arguments);\n  const ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n    let i = states.length,\n      state;\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n  ctor.prototype = new StateMachine();\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    };\n  });\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function () {\n    const numArgs = arguments.length;\n    let states = utils.args(arguments, 0, numArgs - 1);\n    const callback = arguments[numArgs - 1];\n    if (!states.length) states = this.stateNames;\n    const _this = this;\n    const paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};","map":{"version":3,"names":["utils","require","StateMachine","module","exports","ctor","states","args","arguments","apply","paths","stateNames","i","length","state","prototype","forEach","path","_changeState","nextState","prevBucket","clear","keys","Object","some","_this","what","Array","call","_iter","iterMethod","numArgs","callback","reduce","concat","map"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/statemachine.js"],"sourcesContent":["\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst utils = require('./utils');\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function() {\n  const states = utils.args(arguments);\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n\n    let i = states.length,\n        state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    const numArgs = arguments.length;\n    let states = utils.args(arguments, 0, numArgs - 1);\n    const callback = arguments[numArgs - 1];\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}