{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst idGetter = require('./plugins/idGetter');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\nconst arrayAtomicsBackupSymbol = Symbol('mongoose.Array#atomicsBackup');\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n  const defaults = get(options, 'defaults', true);\n  options.defaults = defaults;\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n  this.$locals = {};\n  this.$op = null;\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n  const schema = this.$__schema;\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n  this.$__.emitter.setMaxListeners(0);\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.isNew\n      });\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n  this.$__._id = this._id;\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n});\nDocument.prototype.constructor = Document;\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * ####Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$op;\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n    if (p === '_id' && skipId) {\n      continue;\n    }\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.$__schema.paths).\n  // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n  this.$__init(doc, opts);\n  if (fn) {\n    fn(null, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n  this.$__._id = this._id;\n  return this;\n};\n\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);\n        }\n        break;\n      }\n    }\n  }\n}\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n  while (index < len) {\n    _init(index++);\n  }\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.$__schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.$__schema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n  if (callback != null) {\n    return query.exec(callback);\n  }\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' + 'called `endSession()` on the session you are passing to `$session()`.');\n  }\n  this.$__.session = session;\n  if (!this.ownerDocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  const typeKey = this.$__schema.options.typeKey;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = 'strict' in options ? options.strict : this.$__.strictMode;\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  if (path == null) {\n    const _ = path;\n    path = val;\n    val = _;\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      const _ = path;\n      path = val;\n      val = _;\n    }\n    prefix = val ? val + '.' : '';\n    keys = Object.keys(path);\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true && !prefix && path[key] != null && pathtype === 'nested' && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: true\n        });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: false\n        });\n      }\n      const someCondition = typeof path[key] === 'object' && !utils.isNativeObject(path[key]) && !utils.isMongooseType(path[key]) && path[key] != null && pathtype !== 'virtual' && pathtype !== 'real' && pathtype !== 'adhocOrUndefined' && !(this.$__path(pathName) instanceof MixedSchema) && !(this.$__schema.paths[pathName] && this.$__schema.paths[pathName].options && this.$__schema.paths[pathName].options.ref);\n      if (someCondition) {\n        this.$__.$setCalled.add(prefix + key);\n        this.$set(path[key], prefix + key, constructing, options);\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 && this.get(pathName) !== void 0) {\n          continue;\n        }\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n            typeOnly: true\n          });\n        }\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          // Check for setting single embedded schema to document (gh-3535)\n          let p = path[key];\n          if (this.$__schema.paths[pathName] && this.$__schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {\n            p = p.toObject({\n              virtuals: false,\n              transform: false\n            });\n          }\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key, path[key].toObject({\n            transform: false\n          }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n    return this;\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const priorVal = this.$__getValue(path);\n        this.$__.savedState[path] = priorVal;\n        const keys = Object.keys(priorVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = priorVal[key];\n        }\n      }\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      cleanModifiedSubpaths(this, path, {\n        skipDocArrays: true\n      });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n    return this;\n  }\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, {\n        [populateModelSymbol]: val.constructor\n      });\n      val.$__.wasPopulated = true;\n      didPopulate = true;\n    }\n    let popOpts;\n    if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = {\n        [populateModelSymbol]: val[0].constructor\n      };\n      this.populated(path, val.map(function (v) {\n        return v._id;\n      }), popOpts);\n      for (const doc of val) {\n        doc.$__.wasPopulated = true;\n      }\n      didPopulate = true;\n    }\n    if (this.$__schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n    if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath, val.map(v => v.populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val[i] = val[i]._id;\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    if (this.$__.savedState != null) {\n      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        this.$__.savedState[path] = priorVal;\n      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {\n        this.unmarkModified(path);\n      }\n    }\n  }\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);\n  const _this = this;\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function (modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], {\n        getters: false\n      });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n  if (arguments.length > 0) {\n    const v = this.get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function (list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function (chain) {\n      return list.indexOf(chain) === -1;\n    }));\n    if (!options.includeChildren) {\n      return list;\n    }\n    let cur = _this.get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).filter(function (key) {\n          return list.indexOf(path + '.' + key) === -1;\n        }).forEach(function (key) {\n          list.push(path + '.' + key);\n        });\n      }\n    }\n    return list;\n  }, []);\n};\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n  if (inclusive === null) {\n    return true;\n  }\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n  const pathDot = path + '.';\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n  if (inclusive === null) {\n    return true;\n  }\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function (pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n  if (this.ownerDocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack\n    });\n  }\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n    this.$__validate(pathsToValidate, options, error => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.$__schema.path(path);\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.$__isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n  function addToPaths(p) {\n    paths.add(p);\n  }\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isMongooseArray ||\n    // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    _pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required')) {\n      continue;\n    }\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n  const flattenOptions = {\n    skipArrays: true\n  };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function (pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  const pathsToSkip = get(options, 'pathsToSkip', null);\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    this.$__.validating = null;\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  if (paths.length === 0) {\n    return immediate(function () {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n  const validated = {};\n  let total = 0;\n  for (const path of paths) {\n    validatePath(path);\n  }\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n    validated[path] = true;\n    total++;\n    immediate(function () {\n      const schemaType = _this.$__schema.path(path);\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n      const scope = path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n      schemaType.doValidate(val, function (err) {\n        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (schemaType.$isSingleNested && err instanceof ValidationError && schemaType.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n  let pathsToSkip = options && options.pathsToSkip;\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n  paths.forEach(function (path) {\n    if (validating[path]) {\n      return;\n    }\n    validating[path] = true;\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested && err instanceof ValidationError && p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function (path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).forEach(function (array) {\n    let i = array.length;\n    while (i--) {\n      const doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n    _this.$__.activePaths.init(array.$path());\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  });\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val.$isSingleNested;\n  }).forEach(function (doc) {\n    doc.$__reset();\n    if (doc.$__parent === _this) {\n      _this.$__.activePaths.init(doc.$basePath);\n    } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {\n      // If map path underneath subdocument, may end up with a case where\n      // map path is modified but parent still needs to be reset. See gh-10295\n      doc.$__parent.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n  this.$__.validationError = this.$__.backup.validationError;\n  this.errors = this.$__.backup.errors;\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function (a, b) {\n    return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  let lastPath;\n  let top;\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n  top = lastPath = null;\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function (schema) {\n  schema.plugin(idGetter, {\n    deduplicate: true\n  });\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function $getAllSubdocs() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, '$__schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps\n  });\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n  const depopulate = options.depopulate || get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n    hasKeys = true;\n  }\n  return hasKeys ? obj : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n  if (!cur) {\n    return json;\n  }\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substr(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n  return json;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n  if (!cur) {\n    return json;\n  }\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n  return json;\n}\n\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n  if (!cur) {\n    return json;\n  }\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n      json[path] = vals;\n    }\n  }\n  return json;\n}\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n  if (!cur) {\n    return json;\n  }\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function () {\n  return this.$__.parent;\n};\n\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n  return ret;\n};\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n    if (this.$__isNested) {\n      topLevelModel = this.$__[scopeSymbol].constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function (populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    }\n\n    // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = {\n            session: session\n          };\n          return;\n        }\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n    topLevelModel.populate(this, paths, fn);\n  }\n  return this;\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @instance\n */\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  if (this.$$populatedVirtuals != null) {\n    keys = keys.concat(Object.keys(this.$$populatedVirtuals));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for promises integration.\n *\n * ####Example:\n *\n *     const promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *   // you can also use doc.execPopulate(options) as a shorthand for\n *   // doc.populate(options).execPopulate()\n *\n *\n * ####Example:\n *   const promise = doc.execPopulate({ path: 'company', select: 'employees' });\n *\n *   // summary\n *   promise.then(resolve,reject);\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.execPopulate = function (callback) {\n  const isUsingShorthand = callback != null && typeof callback !== 'function';\n  if (isUsingShorthand) {\n    return this.populate.apply(this, arguments).execPopulate();\n  }\n  return promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n    const keys = Object.keys(populated);\n    for (const key of keys) {\n      populatedIds = this.populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n  for (const singlePath of path) {\n    populatedIds = this.populated(singlePath);\n    delete populated[singlePath];\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function () {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","ParallelValidateError","Schema","StrictModeError","ValidationError","ValidatorError","VirtualType","promiseOrCallback","cleanModifiedSubpaths","compile","defineKey","flatten","get","getEmbeddedDiscriminatorPath","handleSpreadDoc","idGetter","immediate","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","mpath","queryhelpers","utils","isPromise","clone","deepEqual","isMongooseObject","arrayAtomicsBackupSymbol","Symbol","arrayAtomicsSymbol","documentArrayParent","documentIsModified","documentModifiedPaths","documentSchemaSymbol","getSymbol","populateModelSymbol","scopeSymbol","schemaMixedSymbol","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","Object","assign","defaults","$__schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","emitter","isNew","errors","undefined","$options","$locals","$op","schema","strictMode","strict","selected","requiredPaths","path","activePaths","setMaxListeners","exclude","isPOJO","hasIncludedChildren","$__hasIncludedChildren","_doc","$__buildDoc","$__applyDefaults","$__original_set","$set","willInit","prototype","once","call","skipDefaults","_id","_this","keys","forEach","key","tree","applyQueue","each","emitterFn","apply","constructor","i","defineProperty","configurable","enumerable","writable","id","parts","split","c","part","push","join","doc","isBeforeSetters","pathsToSkip","paths","plen","length","def","curPath","p","type","splitPath","len","included","doc_","j","piece","defaultValue","$runBeforeSetters","getDefault","err","invalidate","default","filter","includes","ii","last","toBSON","toObject","init","opts","fn","$__init","$init","populated","String","item","isVirtual","getValue","_docs","_childDocs","child","parent","markArraySubdocsPopulated","emit","pieces","subpath","slice","rest","val","isMongooseDocumentArray","self","prefix","index","_init","$isRootDiscriminator","$__isSelected","_castNullish","intCache","wasPopulated","cast","e","message","value","reason","isModified","update","args","unshift","query","$session","session","updateOne","callback","pre","cb","_middleware","execPre","post","execPost","exec","replaceOne","hasEnded","ownerDocument","subdocs","$getAllSubdocs","overwrite","Array","from","Set","concat","versionKey","discriminatorKey","merge","adhoc","constructing","typeKey","adhocs","pathtype","adhocPaths","interpretAsType","_","$__isNested","_skipMinimizeTopLevel","pathName","pathType","someCondition","isNativeObject","isMongooseType","$__path","ref","$setCalled","add","typeOnly","$isSingleNested","virtuals","transform","hasPriorVal","savedState","hasOwnProperty","priorVal","$__getValue","$__setValue","unmarkModified","markModified","skipDocArrays","CastError","indexOf","aliases","mixed","set","virtualpath","applySetters","cur","pathToMark","getters","priorDoc","$__set","$isMongooseArray","_markValidSubpaths","shouldSet","refMatches","model","modelName","baseModelName","refPath","didPopulate","popOpts","isArray","_isManuallyPopulatedArray","map","v","singleNestedPaths","$isMongooseDocumentArray","populatedPaths","populatedPath","_checkImmutableSubpaths","$markValid","isImmutableError","$originalErrorPath","instance","isDirectModified","el","$__shouldModify","states","shouldModify","isMongooseArray","_registerAtomic","__parentArray","modifiedPath","startsWith","ignore","l","next","has","Map","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","scope","modify","pathsToScopes","$ignore","directModifiedPaths","$isEmpty","isEmptyOptions","minimize","_isEmpty","modifiedPaths","reduce","list","chains","chain","includeChildren","modified","childPath","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","isSelected","inclusive","pathDot","isDirectSelected","validate","pathsToValidate","parallelValidate","validating","parentStack","conflictStack","stack","isOnePathOnly","$__validate","error","events","_evaluateRequiredFunctions","originalRequiredValue","cachedRequired","_getPathsToValidate","skipSchemaValidators","addToPaths","subdoc","$basePath","delete","_pathType","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","validationError","errPath","pathDetails","_handlePathsToValidate","_handlePathsToSkip","s","hooks","validated","total","validatePath","schemaType","complete","$isValid","pop","doValidateOptions","doValidate","$isArrayValidatorError","storeSubdocValidationError","_pathsToValidate","parentPaths","ret","validateSync","doValidateSync","kind","addError","schematype","$immutableSetter","oldVal","$__reset","reset","array","$path","$__parent","$__dirty","dirt","backup","clear","$__undoReset","all","sort","a","b","minimal","lastPath","top","hasAtomics","plugin","deduplicate","_applyDefaultGetters","$__getArrayPathsToValidate","bind","seed","docReducer","isNested","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","schemaOptions","_calledWithOptions","_minimize","flattenMaps","cloneOptions","_isNested","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","applySchemaTypeTransforms","useProjection","omitDeselectedFields","toJSON","xformed","hasKeys","Buffer","isBuffer","toObjectOptions","numPaths","assignPath","virtualsToApply","substr","branch","transformedValue","throwErrorIfPromise","$embeddedSchemaType","vals","Error","applyPaths","$parent","custom","toString","equals","tid","docid","populate","res","populateOptions","object","topLevelModel","nestedPath","$getPopulatedDocs","$$populatedVirtuals","result","execPopulate","isUsingShorthand","_path","endsWith","replace","populatedIds","virtualKeys","virtualKey","singlePath","$__fullPath","getChanges","delta","$__delta","changes","module","exports"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/document.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst idGetter = require('./plugins/idGetter');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = Symbol('mongoose.Array#atomicsBackup');\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n  const defaults = get(options, 'defaults', true);\n  options.defaults = defaults;\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n  this.$locals = {};\n  this.$op = null;\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.isNew\n      });\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * ####Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$op;\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n\n  this.$__._id = this._id;\n  return this;\n};\n\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);\n        }\n        break;\n      }\n    }\n  }\n}\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.$__schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.$__schema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  const typeKey = this.$__schema.options.typeKey;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    const _ = path;\n    path = val;\n    val = _;\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      const _ = path;\n      path = val;\n      val = _;\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = Object.keys(path);\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          path[key] != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null &&\n          Object.keys(this._doc[key]).length === 0) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n      }\n\n      const someCondition = typeof path[key] === 'object' &&\n                            !utils.isNativeObject(path[key]) &&\n                            !utils.isMongooseType(path[key]) &&\n                            path[key] != null &&\n                            pathtype !== 'virtual' &&\n                            pathtype !== 'real' &&\n                            pathtype !== 'adhocOrUndefined' &&\n                            !(this.$__path(pathName) instanceof MixedSchema) &&\n                            !(this.$__schema.paths[pathName] &&\n                            this.$__schema.paths[pathName].options &&\n                            this.$__schema.paths[pathName].options.ref);\n\n      if (someCondition) {\n        this.$__.$setCalled.add(prefix + key);\n        this.$set(path[key], prefix + key, constructing, options);\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 &&\n            this.get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          // Check for setting single embedded schema to document (gh-3535)\n          let p = path[key];\n          if (this.$__schema.paths[pathName] &&\n              this.$__schema.paths[pathName].$isSingleNested &&\n              path[key] instanceof Document) {\n            p = p.toObject({ virtuals: false, transform: false });\n          }\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key,\n            path[key].toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    return this;\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const priorVal = this.$__getValue(path);\n        this.$__.savedState[path] = priorVal;\n\n        const keys = Object.keys(priorVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = priorVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n\n      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      cleanModifiedSubpaths(this, path, { skipDocArrays: true });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = true;\n      didPopulate = true;\n    }\n\n    let popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = true;\n      }\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath,\n          val.map(v => v.populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val[i] = val[i]._id;\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n\n    if (this.$__.savedState != null) {\n      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        this.$__.savedState[path] = priorVal;\n      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {\n        this.unmarkModified(path);\n      }\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function(list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).\n          filter(function(key) {\n            return list.indexOf(path + '.' + key) === -1;\n          }).\n          forEach(function(key) {\n            list.push(path + '.' + key);\n          });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.ownerDocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&\n            !doc.isDirectModified(subdoc.$basePath) &&\n            !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType ||\n        !_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = get(options, 'pathsToSkip', null);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    this.$__.validating = null;\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n      const scope = path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n      schemaType.doValidate(val, function(err) {\n        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (schemaType.$isSingleNested &&\n              err instanceof ValidationError &&\n              schemaType.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested &&\n          err instanceof ValidationError &&\n          p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    })\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    })\n    .forEach(function(array) {\n      let i = array.length;\n      while (i--) {\n        const doc = array[i];\n        if (!doc) {\n          continue;\n        }\n        doc.$__reset();\n      }\n\n      _this.$__.activePaths.init(array.$path());\n\n      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n      array[arrayAtomicsSymbol] = {};\n    });\n\n  this.$__.activePaths.\n    map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    }).\n    filter(function(val) {\n      return val && val.$isSingleNested;\n    }).\n    forEach(function(doc) {\n      doc.$__reset();\n      if (doc.$__parent === _this) {\n        _this.$__.activePaths.init(doc.$basePath);\n      } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {\n        // If map path underneath subdocument, may end up with a case where\n        // map path is modified but parent still needs to be reset. See gh-10295\n        doc.$__parent.$__reset();\n      }\n    });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  let lastPath;\n  let top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null &&\n        top.value != null &&\n        top.value[arrayAtomicsSymbol] != null &&\n        top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n  top = lastPath = null;\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  schema.plugin(idGetter, { deduplicate: true });\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function $getAllSubdocs() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, '$__schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  }\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substr(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  return this.$__.parent;\n};\n\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n    if (this.$__isNested) {\n      topLevelModel = this.$__[scopeSymbol].constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function(populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    }\n\n    // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = { session: session };\n          return;\n        }\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @instance\n */\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  if (this.$$populatedVirtuals != null) {\n    keys = keys.concat(Object.keys(this.$$populatedVirtuals));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for promises integration.\n *\n * ####Example:\n *\n *     const promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *   // you can also use doc.execPopulate(options) as a shorthand for\n *   // doc.populate(options).execPopulate()\n *\n *\n * ####Example:\n *   const promise = doc.execPopulate({ path: 'company', select: 'employees' });\n *\n *   // summary\n *   promise.then(resolve,reject);\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.execPopulate = function(callback) {\n  const isUsingShorthand = callback != null && typeof callback !== 'function';\n  if (isUsingShorthand) {\n    return this.populate.apply(this, arguments).execPopulate();\n  }\n\n  return promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"],"mappings":"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,CAAC,IAAI,EAAEmJ,GAAG,EAAErU,OAAO,CAAC;IAC7C,IAAI,OAAOoY,OAAO,KAAK,WAAW,EAAE;MAClC/D,GAAG,GAAG+D,OAAO;IACf;EACF;EAEA,OAAO/D,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAzU,QAAQ,CAACwC,SAAS,CAACsD,QAAQ,GAAG,UAAS1F,OAAO,EAAE;EAC9C,OAAO,IAAI,CAAC+W,SAAS,CAAC/W,OAAO,CAAC;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS2P,QAAQ,CAAC9P,GAAG,EAAE;EACrB,MAAM6C,IAAI,GAAGzC,MAAM,CAACyC,IAAI,CAAC7C,GAAG,CAAC;EAC7B,IAAIsD,CAAC,GAAGT,IAAI,CAAC0B,MAAM;EACnB,IAAIiU,OAAO;EACX,IAAIzV,GAAG;EACP,IAA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}