{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\nconst modifiedPaths = require('./common').modifiedPaths;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function (query, schema, castedDoc, options, callback) {\n  let _keys;\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' || key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n  const alreadyValidated = [];\n  const context = options && options.context === 'query' ? query : null;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              err.path = updates[i] + '.$in.' + i;\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] && schemaPath.$isMongooseArray) {\n        return;\n      }\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n              return callback(null);\n            }\n            v.validate(function (err) {\n              if (err) {\n                if (err.errors) {\n                  for (const key of Object.keys(err.errors)) {\n                    const _err = err.errors[key];\n                    _err.path = updates[i] + '.' + key;\n                    validationErrors.push(_err);\n                  }\n                } else {\n                  err.path = updates[i];\n                  validationErrors.push(err);\n                }\n              }\n              callback(null);\n            });\n          }, context, {\n            updateValidator: true\n          });\n        });\n      } else {\n        validatorsToExecute.push(function (callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n          schemaPath.doValidate(v, function (err) {\n            if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {\n              return callback(null);\n            }\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function (callback) {\n        schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n    return;\n  }\n  return function (callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n      return callback(err);\n    }\n    callback(null);\n  }\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function (err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};","map":{"version":3,"names":["ValidationError","require","cleanPositionalOperators","flatten","modifiedPaths","module","exports","query","schema","castedDoc","options","callback","_keys","keys","Object","updatedKeys","updatedValues","isPull","arrayAtomicUpdates","numKeys","length","hasDollarUpdate","modified","currentUpdate","key","i","startsWith","ii","$each","concat","flat","paths","numPaths","j","updatedPath","includes","undefined","updates","numUpdates","validatorsToExecute","validationErrors","alreadyValidated","context","iter","v","schemaPath","_getSchema","instance","path","Array","isArray","$in","forEach","push","doValidate","err","updateValidator","$isMongooseArray","$isMongooseDocumentArrayElement","$__","validate","errors","_err","storeSubdocValidationError","arrayUpdates","arrayUpdate","$isMongooseDocumentArray","getValidationCallback","atomicUpdate","numValidators","_done","validator","validationError","addError"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/updateValidators.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\nconst modifiedPaths = require('./common').modifiedPaths;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  let _keys;\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = options && options.context === 'query' ? query : null;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n              return callback(null);\n            }\n\n            v.validate(function(err) {\n              if (err) {\n                if (err.errors) {\n                  for (const key of Object.keys(err.errors)) {\n                    const _err = err.errors[key];\n                    _err.path = updates[i] + '.' + key;\n                    validationErrors.push(_err);\n                  }\n                } else {\n                  err.path = updates[i];\n                  validationErrors.push(err);\n                }\n              }\n              callback(null);\n            });\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}