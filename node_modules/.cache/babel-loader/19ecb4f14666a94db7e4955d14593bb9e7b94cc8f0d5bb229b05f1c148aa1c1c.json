{"ast":null,"code":"'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\nmodule.exports = assignRawDocsToIdStructure;\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n  for (let i = 0; i < rawIds.length; ++i) {\n    id = rawIds[i];\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (Array.isArray(_resultOrder) && Array.isArray(doc) && _resultOrder.length === doc.length) {\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function (doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}","map":{"version":3,"names":["leanPopulateMap","require","modelSymbol","utils","module","exports","assignRawDocsToIdStructure","rawIds","resultDocs","resultOrder","options","recursed","newOrder","sorting","sort","length","nullIfNotFound","$nullIfNotFound","doc","sid","id","i","Array","isArray","push","String","clone","lean","_model","get","set","constructor","hydrate","_doc","_resultOrder","retainNullValues","forEach"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  for (let i = 0; i < rawIds.length; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (Array.isArray(_resultOrder) && Array.isArray(doc) && _resultOrder.length === doc.length) {\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}