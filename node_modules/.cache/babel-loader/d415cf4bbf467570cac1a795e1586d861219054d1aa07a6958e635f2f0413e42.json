{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/*!\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\nmodule.exports = function getSchemaTypes(schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' + foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).reduce(function (cur, discriminator) {\n            const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n            if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n              cur.push(discriminators[discriminator]);\n            }\n            return cur;\n          }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n          const ret = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            return ret;\n          }\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      }\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !model.schema.$isSingleNested;\n          }\n          return ret;\n        }\n      }\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !schema.$isSingleNested;\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};","map":{"version":3,"names":["Mixed","require","get","leanPopulateMap","mpath","populateModelSymbol","module","exports","getSchemaTypes","schema","doc","path","pathschema","topLevelDoc","search","parts","subdoc","nestedPath","p","length","foundschema","trypath","slice","join","caster","schemas","discriminators","discriminatorKeyPath","options","discriminatorKey","keys","Object","reduce","cur","discriminator","tiedValue","discriminatorMapping","value","indexOf","push","ret","concat","$isUnderneathDocArray","$isSingleNested","_ret","$isMongooseArray","casterConstructor","type","$isMongooseDocumentArray","discriminatorPaths","discriminatorName","_schema","fullPath","$__","populated","model","_val","Array","isArray","split","i"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/*!\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\nmodule.exports = function getSchemaTypes(schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !model.schema.$isSingleNested;\n          }\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !schema.$isSingleNested;\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}