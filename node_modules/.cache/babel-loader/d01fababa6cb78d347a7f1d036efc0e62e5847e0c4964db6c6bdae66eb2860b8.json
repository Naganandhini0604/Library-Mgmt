{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @param {Query} context passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  // bson 1.x has the unfortunate tendency to remove filters that have a top-level\n  // `_bsontype` property. But we should still allow ObjectIds because\n  // `Collection#find()` has a special case to support `find(objectid)`.\n  // Should remove this when we upgrade to bson 4.x. See gh-8222, gh-8268\n  if (obj.hasOwnProperty('_bsontype') && obj._bsontype !== 'ObjectID') {\n    delete obj._bsontype;\n  }\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = get(_schematype, 'schema.options.discriminatorKey');\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null && get(_schematype, 'schema.discriminators') != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            if (discriminatorVal != null) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);\n            }\n          }\n        }\n      }\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n        if (schema.nested[path]) {\n          continue;\n        }\n        if (options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        } else if (options.strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (options.strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (getConstructorName(val) === 'Object') {\n        any$conditionals = Object.keys(val).some(isOperator);\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQueryWrapper({\n            val: _val,\n            context: context\n          }));\n        }\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n  return obj;\n};\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQueryWrapper({\n        val: item,\n        context: context\n      });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}","map":{"version":3,"names":["CastError","require","StrictModeError","Types","castTextSearch","get","getConstructorName","getSchemaDiscriminatorByValue","isOperator","util","isObject","isMongooseObject","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","hasOwnProperty","_bsontype","discriminators","discriminatorKey","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","toString","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorVal","remainingConds","caster","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQueryWrapper","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","toObject","transform","virtuals","geoWithinType","indexOf","_cast","upsert","strict","strictQuery","some","ks","$cond","key","$conditional","instance","casted","valuesArray","_val","push","$in","forEach","item","nearKeys","nearLen","nkey","castForQuery"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/cast.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @param {Query} context passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  // bson 1.x has the unfortunate tendency to remove filters that have a top-level\n  // `_bsontype` property. But we should still allow ObjectIds because\n  // `Collection#find()` has a special case to support `find(objectid)`.\n  // Should remove this when we upgrade to bson 4.x. See gh-8222, gh-8268\n  if (obj.hasOwnProperty('_bsontype') && obj._bsontype !== 'ObjectID') {\n    delete obj._bsontype;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = get(_schematype, 'schema.options.discriminatorKey');\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n              get(_schematype, 'schema.discriminators') != null &&\n              discriminatorKey != null &&\n              pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            if (discriminatorVal != null) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].\n                path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n        if (options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } else if (options.strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (options.strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (getConstructorName(val) === 'Object') {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQueryWrapper({\n            val: _val,\n            context: context\n          }));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQueryWrapper({ val: item, context: context });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}