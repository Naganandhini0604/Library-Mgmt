{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst immediate = require('../immediate');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const enqueue = asyncQueue();\n  return promiseOrCallback(callback, cb => {\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      }\n      if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n      if (batchSize !== Math.floor(batchSize)) {\n        throw new TypeError('batchSize must be a positive integer');\n      }\n    }\n    iterate(cb);\n  });\n  function iterate(finalCallback) {\n    let drained = false;\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let documentsBatch = [];\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(fetch);\n    }\n    function fetch(done) {\n      if (drained || error) {\n        return done();\n      }\n      next(function (err, doc) {\n        if (drained || error != null) {\n          return done();\n        }\n        if (err != null) {\n          error = err;\n          finalCallback(err);\n          return done();\n        }\n        if (doc == null) {\n          drained = true;\n          if (handleResultsInProgress <= 0) {\n            finalCallback(null);\n          } else if (batchSize != null && documentsBatch.length) {\n            handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n          }\n          return done();\n        }\n        ++handleResultsInProgress;\n\n        // Kick off the subsequent `next()` before handling the result, but\n        // make sure we know that we still have a result to handle re: #8422\n        immediate(() => done());\n        if (batchSize != null) {\n          documentsBatch.push(doc);\n        }\n\n        // If the current documents size is less than the provided patch size don't process the documents yet\n        if (batchSize != null && documentsBatch.length !== batchSize) {\n          setTimeout(() => enqueue(fetch), 0);\n          return;\n        }\n        const docsToProcess = batchSize != null ? documentsBatch : doc;\n        function handleNextResultCallBack(err) {\n          if (batchSize != null) {\n            handleResultsInProgress -= documentsBatch.length;\n            documentsBatch = [];\n          } else {\n            --handleResultsInProgress;\n          }\n          if (err != null) {\n            error = err;\n            return finalCallback(err);\n          }\n          if (drained && handleResultsInProgress <= 0) {\n            return finalCallback(null);\n          }\n          setTimeout(() => enqueue(fetch), 0);\n        }\n        handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n      });\n    }\n  }\n  function handleNextResult(doc, i, callback) {\n    const promise = fn(doc, i);\n    if (promise && typeof promise.then === 'function') {\n      promise.then(function () {\n        callback(null);\n      }, function (error) {\n        callback(error || new Error('`eachAsync()` promise rejected without error'));\n      });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n  return function enqueue(fn) {\n    if (_queue.length === 0 && inProgress == null) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n  function _step() {\n    inProgress = null;\n    if (_queue.length > 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    }\n  }\n}","map":{"version":3,"names":["immediate","require","promiseOrCallback","module","exports","eachAsync","next","fn","options","callback","parallel","batchSize","enqueue","asyncQueue","cb","TypeError","Math","floor","iterate","finalCallback","drained","handleResultsInProgress","currentDocumentIndex","documentsBatch","error","i","fetch","done","err","doc","length","handleNextResult","handleNextResultCallBack","push","setTimeout","docsToProcess","promise","then","Error","_queue","inProgress","id","_step","shift"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst immediate = require('../immediate');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const enqueue = asyncQueue();\n\n  return promiseOrCallback(callback, cb => {\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      }\n      if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n      if (batchSize !== Math.floor(batchSize)) {\n        throw new TypeError('batchSize must be a positive integer');\n      }\n    }\n\n    iterate(cb);\n  });\n\n  function iterate(finalCallback) {\n    let drained = false;\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let documentsBatch = [];\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(fetch);\n    }\n\n    function fetch(done) {\n      if (drained || error) {\n        return done();\n      }\n\n      next(function(err, doc) {\n        if (drained || error != null) {\n          return done();\n        }\n        if (err != null) {\n          error = err;\n          finalCallback(err);\n          return done();\n        }\n        if (doc == null) {\n          drained = true;\n          if (handleResultsInProgress <= 0) {\n            finalCallback(null);\n          } else if (batchSize != null && documentsBatch.length) {\n            handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n          }\n          return done();\n        }\n\n        ++handleResultsInProgress;\n\n        // Kick off the subsequent `next()` before handling the result, but\n        // make sure we know that we still have a result to handle re: #8422\n        immediate(() => done());\n\n        if (batchSize != null) {\n          documentsBatch.push(doc);\n        }\n\n        // If the current documents size is less than the provided patch size don't process the documents yet\n        if (batchSize != null && documentsBatch.length !== batchSize) {\n          setTimeout(() => enqueue(fetch), 0);\n          return;\n        }\n\n        const docsToProcess = batchSize != null ? documentsBatch : doc;\n\n        function handleNextResultCallBack(err) {\n          if (batchSize != null) {\n            handleResultsInProgress -= documentsBatch.length;\n            documentsBatch = [];\n          } else {\n            --handleResultsInProgress;\n          }\n          if (err != null) {\n            error = err;\n            return finalCallback(err);\n          }\n          if (drained && handleResultsInProgress <= 0) {\n            return finalCallback(null);\n          }\n\n          setTimeout(() => enqueue(fetch), 0);\n        }\n\n        handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n      });\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    const promise = fn(doc, i);\n    if (promise && typeof promise.then === 'function') {\n      promise.then(\n        function() { callback(null); },\n        function(error) { callback(error || new Error('`eachAsync()` promise rejected without error')); });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (_queue.length === 0 && inProgress == null) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    inProgress = null;\n    if (_queue.length > 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}