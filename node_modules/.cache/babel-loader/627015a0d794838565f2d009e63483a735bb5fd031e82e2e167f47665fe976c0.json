{"ast":null,"code":"'use strict';\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n    const _allIds = o.allIds[i];\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n    if (o.isVirtual && isDoc) {\n      docs[i].populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      mpath.set(_path, valueToSet, docs[i], setValue);\n      continue;\n    }\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n      if (parts[j] === '$*') {\n        break;\n      }\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      docs[i].populated(_path, o.allIds[i], o.allOptions);\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n  }\n};\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el))) {\n      return v.map(el => numDocs(el));\n    }\n    return v.length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > ret.length) {\n      Array.prototype.pop.apply(val, []);\n    }\n    for (let i = 0; i < ret.length; ++i) {\n      val[i] = ret[i];\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/*!\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n  return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);\n}\nfunction noop(v) {\n  return v;\n}","map":{"version":3,"names":["SkipPopulateValue","require","assignRawDocsToIdStructure","get","getVirtual","leanPopulateMap","lookupLocalFields","mpath","sift","default","utils","module","exports","assignVals","o","userOptions","Object","assign","populateOptions","options","justOne","$nullIfNotFound","isVirtual","populatedModel","originalIds","concat","rawIds","allIds","rawDocs","rawOrder","docs","count","i","setValue","val","_allIds","Array","isArray","ret","doc","_docPopulatedModel","push","length","prototype","pop","apply","valueFilter","_path","path","endsWith","slice","existingVal","originalModel","schema","valueToSet","numDocs","match","filter","originalSchema","isDoc","isMap","Map","isPOJO","_getSchema","_keys","from","keys","reduce","cur","v","set","$__","parent","populated","allOptions","parts","split","curPath","j","isArrayIndex","schematype","$isMongooseArray","some","el","map","assignmentOpts","userSpecifiedTransform","transform","noop","numValues","subdoc","isPopulatedObject","retainNullValues","maybeRemoveId","originalLimit","excludeId","$__setValue","_doc","_id","obj","$isMongooseMap","has"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/populate/assignVals.js"],"sourcesContent":["'use strict';\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(sift(o.match[i])) :\n        [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      mpath.set(_path, valueToSet, docs[i], setValue);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      docs[i].populated(_path, o.allIds[i], o.allOptions);\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el))) {\n      return v.map(el => numDocs(el));\n    }\n    return v.length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > ret.length) {\n      Array.prototype.pop.apply(val, []);\n    }\n    for (let i = 0; i < ret.length; ++i) {\n      val[i] = ret[i];\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/*!\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}