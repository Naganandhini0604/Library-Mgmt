{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSingleNestedOptions = require('../options/SchemaSingleNestedOptions');\nconst SchemaType = require('../schematype');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst get = require('../helpers/get');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nlet Subdocument;\nmodule.exports = SingleNestedPath;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SingleNestedPath(schema, path, options) {\n  schema = handleIdOption(schema, options);\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype = Object.create(SchemaType.prototype);\nSingleNestedPath.prototype.constructor = SingleNestedPath;\nSingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n  const _embedded = function SingleNested(value, path, parent) {\n    const _this = this;\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n    if (parent) {\n      parent.on('save', function () {\n        _this.emit('save', _this);\n        _this.constructor.emit('save', _this);\n      });\n      parent.on('isNew', function (val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function () {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n  return _embedded;\n}\n\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return {\n    $geometry: this.castForQuery(val.$geometry)\n  };\n};\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype.$conditionalHandlers.$near = SingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\nSingleNestedPath.prototype.$conditionalHandlers.$within = SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\nSingleNestedPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\nSingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\nSingleNestedPath.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSingleNestedPath.prototype.cast = function (val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n  const Constructor = getConstructor(this.caster, val);\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = get(doc, '$__.selected', {});\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, {});\n  options = Object.assign({}, options, {\n    priorDoc: priorVal\n  });\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSingleNestedPath.prototype.castForQuery = function ($conditional, val, options) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n  const Constructor = getConstructor(this.caster, val);\n  const overrideStrict = options != null && options.strict != null ? options.strict : void 0;\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSingleNestedPath.prototype.doValidate = function (value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n    return value.validate(fn);\n  }\n  SchemaType.prototype.doValidate.call(this, value, function (error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n    value.validate(fn);\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSingleNestedPath.prototype.doValidateSync = function (value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators /docs/discriminators.html\n * @api public\n */\n\nSingleNestedPath.prototype.discriminator = function (name, schema, value) {\n  schema = discriminator(this.caster, name, schema, value);\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n  return this.caster.discriminators[name];\n};\n\n/**\n * Sets a default option for all SingleNestedPath instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Embedded.set('required', true);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSingleNestedPath.defaultOptions = {};\nSingleNestedPath.set = SchemaType.set;\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.schema, this.path, options);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};","map":{"version":3,"names":["CastError","require","EventEmitter","ObjectExpectedError","SchemaSingleNestedOptions","SchemaType","$exists","castToNumber","discriminator","geospatial","get","getConstructor","handleIdOption","internalToObjectOptions","Subdocument","module","exports","SingleNestedPath","schema","path","options","caster","_createConstructor","prototype","$basePath","$isSingleNested","call","Object","create","constructor","OptionsConstructor","baseClass","_embedded","SingleNested","value","parent","_this","$__parent","apply","arguments","$session","ownerDocument","on","emit","val","isNew","proto","$__setSchema","events","toBSON","toObject","i","methods","statics","$conditionalHandlers","$geoWithin","handle$geoWithin","$geometry","castForQuery","$near","$nearSphere","cast$near","$within","cast$within","$geoIntersects","cast$geoIntersects","$minDistance","$maxDistance","cast","doc","init","priorVal","Array","isArray","Constructor","subdoc","parentSelected","selected","keys","reduce","obj","key","startsWith","substr","length","assign","priorDoc","undefined","$conditional","handler","Error","runSetters","_applySetters","overrideStrict","strict","error","doValidate","fn","scope","skipSchemaValidators","validate","doValidateSync","schemaTypeError","validateSync","name","discriminators","defaultOptions","set","clone","schematype","validators","slice","requiredValidator"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/schema/SingleNestedPath.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSingleNestedOptions = require('../options/SchemaSingleNestedOptions');\nconst SchemaType = require('../schematype');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst get = require('../helpers/get');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\n\nlet Subdocument;\n\nmodule.exports = SingleNestedPath;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SingleNestedPath(schema, path, options) {\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype = Object.create(SchemaType.prototype);\nSingleNestedPath.prototype.constructor = SingleNestedPath;\nSingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    const _this = this;\n\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n\n    if (parent) {\n      parent.on('save', function() {\n        _this.emit('save', _this);\n        _this.constructor.emit('save', _this);\n      });\n\n      parent.on('isNew', function(val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return { $geometry: this.castForQuery(val.$geometry) };\n};\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype.$conditionalHandlers.$near =\nSingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSingleNestedPath.prototype.$conditionalHandlers.$within =\nSingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSingleNestedPath.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSingleNestedPath.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSingleNestedPath.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = get(doc, '$__.selected', {});\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, {});\n  options = Object.assign({}, options, { priorDoc: priorVal });\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSingleNestedPath.prototype.castForQuery = function($conditional, val, options) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSingleNestedPath.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n    return value.validate(fn);\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn);\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSingleNestedPath.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators /docs/discriminators.html\n * @api public\n */\n\nSingleNestedPath.prototype.discriminator = function(name, schema, value) {\n  schema = discriminator(this.caster, name, schema, value);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/**\n * Sets a default option for all SingleNestedPath instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Embedded.set('required', true);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSingleNestedPath.defaultOptions = {};\n\nSingleNestedPath.set = SchemaType.set;\n\n/*!\n * ignore\n */\n\nSingleNestedPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.schema, this.path, options);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}