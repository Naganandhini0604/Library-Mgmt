{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function () {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' + 'named \"' + method + '\"');\n    }\n    if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      console.warn(`mongoose: the method name \"${method}\" is used by mongoose ` + 'internally, overwriting it may cause bugs. If you\\'re sure you know ' + 'what you\\'re doing, you can suppress this error by using ' + `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};","map":{"version":3,"names":["get","require","module","exports","applyMethods","model","schema","apply","method","Object","defineProperty","prototype","h","k","methods","bind","configurable","keys","fn","tree","hasOwnProperty","Error","reserved","console","warn","$appliedMethods","key","paths","type","$isSingleNested","caster","$isMongooseDocumentArray","Constructor"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/model/applyMethods.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      console.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG,SAASC,YAAY,CAACC,KAAK,EAAEC,MAAM,EAAE;EACpD,SAASC,KAAK,CAACC,MAAM,EAAEF,MAAM,EAAE;IAC7BG,MAAM,CAACC,cAAc,CAACL,KAAK,CAACM,SAAS,EAAEH,MAAM,EAAE;MAC7CR,GAAG,EAAE,YAAW;QACd,MAAMY,CAAC,GAAG,CAAC,CAAC;QACZ,KAAK,MAAMC,CAAC,IAAIP,MAAM,CAACQ,OAAO,CAACN,MAAM,CAAC,EAAE;UACtCI,CAAC,CAACC,CAAC,CAAC,GAAGP,MAAM,CAACQ,OAAO,CAACN,MAAM,CAAC,CAACK,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;QAC7C;QACA,OAAOH,CAAC;MACV,CAAC;MACDI,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ;EACA,KAAK,MAAMR,MAAM,IAAIC,MAAM,CAACQ,IAAI,CAACX,MAAM,CAACQ,OAAO,CAAC,EAAE;IAChD,MAAMI,EAAE,GAAGZ,MAAM,CAACQ,OAAO,CAACN,MAAM,CAAC;IACjC,IAAIF,MAAM,CAACa,IAAI,CAACC,cAAc,CAACZ,MAAM,CAAC,EAAE;MACtC,MAAM,IAAIa,KAAK,CAAC,uDAAuD,GACrE,SAAS,GAAGb,MAAM,GAAG,GAAG,CAAC;IAC7B;IACA,IAAIF,MAAM,CAACgB,QAAQ,CAACd,MAAM,CAAC,IACvB,CAACR,GAAG,CAACM,MAAM,EAAG,iBAAgBE,MAAO,kBAAiB,EAAE,KAAK,CAAC,EAAE;MAClEe,OAAO,CAACC,IAAI,CAAE,8BAA6BhB,MAAO,wBAAuB,GACvE,sEAAsE,GACtE,2DAA2D,GAC1D,oBAAmBA,MAAO,sCAAqC,CAAC;IACrE;IACA,IAAI,OAAOU,EAAE,KAAK,UAAU,EAAE;MAC5Bb,KAAK,CAACM,SAAS,CAACH,MAAM,CAAC,GAAGU,EAAE;IAC9B,CAAC,MAAM;MACLX,KAAK,CAACC,MAAM,EAAEF,MAAM,CAAC;IACvB;EACF;;EAEA;EACAD,KAAK,CAACoB,eAAe,GAAG,IAAI;EAC5B,KAAK,MAAMC,GAAG,IAAIjB,MAAM,CAACQ,IAAI,CAACX,MAAM,CAACqB,KAAK,CAAC,EAAE;IAC3C,MAAMC,IAAI,GAAGtB,MAAM,CAACqB,KAAK,CAACD,GAAG,CAAC;IAC9B,IAAIE,IAAI,CAACC,eAAe,IAAI,CAACD,IAAI,CAACE,MAAM,CAACL,eAAe,EAAE;MACxDrB,YAAY,CAACwB,IAAI,CAACE,MAAM,EAAEF,IAAI,CAACtB,MAAM,CAAC;IACxC;IACA,IAAIsB,IAAI,CAACG,wBAAwB,IAAI,CAACH,IAAI,CAACI,WAAW,CAACP,eAAe,EAAE;MACtErB,YAAY,CAACwB,IAAI,CAACI,WAAW,EAAEJ,IAAI,CAACtB,MAAM,CAAC;IAC7C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}