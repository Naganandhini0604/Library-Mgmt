{"ast":null,"code":"'use strict';\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst parentPaths = require('../path/parentPaths');\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = {\n        $in: ids\n      };\n    }\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = {\n          $in: ids\n        };\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{\n        $or: match.$or\n      }, {\n        $or: $or\n      }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({\n          [foreignField]: {\n            $in: ids\n          }\n        });\n      }\n    }\n  }\n  return match;\n};\n\n/*!\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/*!\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return {\n        $or: [].concat(match.map(m => Object.assign({}, m)))\n      };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}","map":{"version":3,"names":["SkipPopulateValue","require","parentPaths","module","exports","createPopulateQueryFilter","ids","_match","_foreignField","model","skipInvalidIds","match","_formatMatch","size","foreignField","Array","from","foreignSchemaType","schema","path","_filterInvalidIds","$in","_parentPaths","i","length","cur","$elemMatch","slice","$or","isArray","$and","push","filter","v","id","cast","err","concat","map","m","Object","assign"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"],"sourcesContent":["'use strict';\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst parentPaths = require('../path/parentPaths');\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = { $in: ids };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = { $in: ids };\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      }\n    }\n  }\n\n  return match;\n};\n\n/*!\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/*!\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}