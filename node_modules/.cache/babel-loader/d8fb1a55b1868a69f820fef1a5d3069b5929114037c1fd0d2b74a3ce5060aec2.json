{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions = require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst ValidationError = require('../error/validation');\nconst discriminator = require('../helpers/model/discriminator');\nconst get = require('../helpers/get');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst util = require('util');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n  this.$embeddedSchemaType.cast = function (value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = {\n  castNonArrays: true\n};\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n  }\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function (name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n    let count = array && array.length;\n    let error;\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n        if (!(error instanceof ValidationError)) {\n          error.$isArrayValidatorError = true;\n        }\n      }\n      --count || fn(error);\n    }\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n      if (options != null && options.validateModifiedOnly && !doc.isModified()) {\n        --count || fn(error);\n        continue;\n      }\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n  const count = array && array.length;\n  let resultError = null;\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n    if (options != null && options.validateModifiedOnly && !doc.isModified()) {\n      continue;\n    }\n    const subdocValidateError = doc.validateSync();\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function (scope) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n    _subdoc.init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n  return ret;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n  let selected;\n  let subdoc;\n  const _opts = {\n    transform: false,\n    virtuals: false\n  };\n  options = options || {};\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n  if (!(value && value.isMongooseDocumentArray) && !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n  const len = value.length;\n  const initDocumentOptions = {\n    skipId: true,\n    willInit: true\n  };\n  for (let i = 0; i < len; ++i) {\n    if (!value[i]) {\n      continue;\n    }\n    const Constructor = getConstructor(this.casterConstructor, value[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if (value[i].$__ && (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined, undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage, value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n  return hasKeys && selected || undefined;\n}\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.defaultOptions = {};\nDocumentArrayPath.set = SchemaType.set;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;","map":{"version":3,"names":["ArrayType","require","CastError","EventEmitter","SchemaDocumentArrayOptions","SchemaType","ValidationError","discriminator","get","handleIdOption","util","utils","getConstructor","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","DocumentArrayPath","key","schema","options","schemaOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","parentSchemaType","$embeddedSchemaType","required","cast","value","doc","init","$isMongooseDocumentArrayElement","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","apply","arguments","$session","ownerDocument","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","tiedValue","getFunctionName","casterConstructor","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","$isArrayValidatorError","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","undefined","validateModifiedOnly","isModified","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","ret","_subdoc","isNew","assign","$__","activePaths","prev","selected","subdoc","_opts","transform","virtuals","inspect","markModified","skipDocumentArrayCast","arrayPathIndex","initDocumentOptions","skipId","willInit","toObject","__index","$setIndex","scopePaths","id","deepEqual","set","valueInErrorMessage","clone","schematype","validators","slice","requiredValidator","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","substr","defaultOptions","module","exports"],"sources":["/home/ctl/Documents/nodejs/node_modules/mongoose/lib/schema/documentarray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions =\n  require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst ValidationError = require('../error/validation');\nconst discriminator = require('../helpers/model/discriminator');\nconst get = require('../helpers/get');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst util = require('util');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n  this.$embeddedSchemaType.cast = function(value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n  }\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n        if (!(error instanceof ValidationError)) {\n          error.$isArrayValidatorError = true;\n        }\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  const _opts = { transform: false, virtuals: false };\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n\n  const len = value.length;\n  const initDocumentOptions = { skipId: true, willInit: true };\n\n  for (let i = 0; i < len; ++i) {\n    if (!value[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i].$__) &&\n        (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.defaultOptions = {};\n\nDocumentArrayPath.set = SchemaType.set;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}